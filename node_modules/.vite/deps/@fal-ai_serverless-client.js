import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-DZZM6G22.js";

// node_modules/@fal-ai/serverless-client/src/middleware.js
var require_middleware = __commonJS({
  "node_modules/@fal-ai/serverless-client/src/middleware.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TARGET_URL_HEADER = void 0;
    exports.withMiddleware = withMiddleware;
    exports.withProxy = withProxy;
    function withMiddleware(...middlewares) {
      return (config) => middlewares.reduce((configPromise, middleware) => configPromise.then((req) => middleware(req)), Promise.resolve(config));
    }
    exports.TARGET_URL_HEADER = "x-fal-target-url";
    function withProxy(config) {
      if (typeof window === "undefined") {
        return (requestConfig) => Promise.resolve(requestConfig);
      }
      return (requestConfig) => Promise.resolve(Object.assign(Object.assign({}, requestConfig), { url: config.targetUrl, headers: Object.assign(Object.assign({}, requestConfig.headers || {}), { [exports.TARGET_URL_HEADER]: requestConfig.url }) }));
    }
  }
});

// node_modules/@fal-ai/serverless-client/src/response.js
var require_response = __commonJS({
  "node_modules/@fal-ai/serverless-client/src/response.js"(exports) {
    "use strict";
    var __awaiter3 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValidationError = exports.ApiError = void 0;
    exports.defaultResponseHandler = defaultResponseHandler;
    var ApiError = class extends Error {
      constructor({ message, status, body }) {
        super(message);
        this.name = "ApiError";
        this.status = status;
        this.body = body;
      }
    };
    exports.ApiError = ApiError;
    var ValidationError = class extends ApiError {
      constructor(args) {
        super(args);
        this.name = "ValidationError";
      }
      get fieldErrors() {
        if (typeof this.body.detail === "string") {
          return [
            {
              loc: ["body"],
              msg: this.body.detail,
              type: "value_error"
            }
          ];
        }
        return this.body.detail || [];
      }
      getFieldErrors(field) {
        return this.fieldErrors.filter((error) => error.loc[error.loc.length - 1] === field);
      }
    };
    exports.ValidationError = ValidationError;
    function defaultResponseHandler(response) {
      return __awaiter3(this, void 0, void 0, function* () {
        var _a;
        const { status, statusText } = response;
        const contentType = (_a = response.headers.get("Content-Type")) !== null && _a !== void 0 ? _a : "";
        if (!response.ok) {
          if (contentType.includes("application/json")) {
            const body = yield response.json();
            const ErrorType = status === 422 ? ValidationError : ApiError;
            throw new ErrorType({
              message: body.message || statusText,
              status,
              body
            });
          }
          throw new ApiError({ message: `HTTP ${status}: ${statusText}`, status });
        }
        if (contentType.includes("application/json")) {
          return response.json();
        }
        if (contentType.includes("text/html")) {
          return response.text();
        }
        if (contentType.includes("application/octet-stream")) {
          return response.arrayBuffer();
        }
        return response.text();
      });
    }
  }
});

// node_modules/@fal-ai/serverless-client/src/config.js
var require_config = __commonJS({
  "node_modules/@fal-ai/serverless-client/src/config.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.credentialsFromEnv = void 0;
    exports.resolveDefaultFetch = resolveDefaultFetch;
    exports.config = config;
    exports.getConfig = getConfig;
    exports.getRestApiUrl = getRestApiUrl;
    var middleware_1 = require_middleware();
    var response_1 = require_response();
    function resolveDefaultFetch() {
      if (typeof fetch === "undefined") {
        throw new Error("Your environment does not support fetch. Please provide your own fetch implementation.");
      }
      return fetch;
    }
    function hasEnvVariables() {
      return typeof process !== "undefined" && process.env && (typeof process.env.FAL_KEY !== "undefined" || typeof process.env.FAL_KEY_ID !== "undefined" && typeof process.env.FAL_KEY_SECRET !== "undefined");
    }
    var credentialsFromEnv = () => {
      if (!hasEnvVariables()) {
        return void 0;
      }
      if (typeof process.env.FAL_KEY !== "undefined") {
        return process.env.FAL_KEY;
      }
      return `${process.env.FAL_KEY_ID}:${process.env.FAL_KEY_SECRET}`;
    };
    exports.credentialsFromEnv = credentialsFromEnv;
    var DEFAULT_CONFIG = {
      credentials: exports.credentialsFromEnv,
      suppressLocalCredentialsWarning: false,
      requestMiddleware: (request) => Promise.resolve(request),
      responseHandler: response_1.defaultResponseHandler
    };
    var configuration;
    function config(config2) {
      var _a;
      configuration = Object.assign(Object.assign(Object.assign({}, DEFAULT_CONFIG), config2), { fetch: (_a = config2.fetch) !== null && _a !== void 0 ? _a : resolveDefaultFetch() });
      if (config2.proxyUrl) {
        configuration = Object.assign(Object.assign({}, configuration), { requestMiddleware: (0, middleware_1.withMiddleware)((0, middleware_1.withProxy)({ targetUrl: config2.proxyUrl }), configuration.requestMiddleware) });
      }
      const { credentials: resolveCredentials, suppressLocalCredentialsWarning } = configuration;
      const credentials = typeof resolveCredentials === "function" ? resolveCredentials() : resolveCredentials;
      if (typeof window !== "undefined" && credentials && !suppressLocalCredentialsWarning) {
        console.warn("The fal credentials are exposed in the browser's environment. That's not recommended for production use cases.");
      }
    }
    function getConfig() {
      if (!configuration) {
        console.info("Using default configuration for the fal client");
        return Object.assign(Object.assign({}, DEFAULT_CONFIG), { fetch: resolveDefaultFetch() });
      }
      return configuration;
    }
    function getRestApiUrl() {
      return "https://rest.alpha.fal.ai";
    }
  }
});

// node_modules/@fal-ai/serverless-client/package.json
var require_package = __commonJS({
  "node_modules/@fal-ai/serverless-client/package.json"(exports, module) {
    module.exports = {
      name: "@fal-ai/serverless-client",
      description: "Deprecation note: this library has been deprecated in favor of @fal-ai/client",
      version: "0.15.0",
      license: "MIT",
      repository: {
        type: "git",
        url: "https://github.com/fal-ai/fal-js.git",
        directory: "libs/client"
      },
      keywords: [
        "fal",
        "serverless",
        "client",
        "ai",
        "ml"
      ],
      dependencies: {
        "@msgpack/msgpack": "^3.0.0-beta2",
        "eventsource-parser": "^1.1.2",
        robot3: "^0.4.1"
      },
      engines: {
        node: ">=18.0.0"
      },
      main: "./src/index.js",
      type: "commonjs"
    };
  }
});

// node_modules/@fal-ai/serverless-client/src/runtime.js
var require_runtime = __commonJS({
  "node_modules/@fal-ai/serverless-client/src/runtime.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBrowser = isBrowser;
    exports.getUserAgent = getUserAgent;
    function isBrowser() {
      return typeof window !== "undefined" && typeof window.document !== "undefined";
    }
    var memoizedUserAgent = null;
    function getUserAgent() {
      if (memoizedUserAgent !== null) {
        return memoizedUserAgent;
      }
      const packageInfo = require_package();
      memoizedUserAgent = `${packageInfo.name}/${packageInfo.version}`;
      return memoizedUserAgent;
    }
  }
});

// node_modules/@fal-ai/serverless-client/src/request.js
var require_request = __commonJS({
  "node_modules/@fal-ai/serverless-client/src/request.js"(exports) {
    "use strict";
    var __awaiter3 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __rest = exports && exports.__rest || function(s, e) {
      var t = {};
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dispatchRequest = dispatchRequest;
    var config_1 = require_config();
    var runtime_1 = require_runtime();
    var isCloudflareWorkers = typeof navigator !== "undefined" && (navigator === null || navigator === void 0 ? void 0 : navigator.userAgent) === "Cloudflare-Workers";
    function dispatchRequest(method_1, targetUrl_1, input_1) {
      return __awaiter3(this, arguments, void 0, function* (method, targetUrl, input, options = {}) {
        var _a;
        const { credentials: credentialsValue, requestMiddleware, responseHandler, fetch: fetch2 } = (0, config_1.getConfig)();
        const userAgent = (0, runtime_1.isBrowser)() ? {} : { "User-Agent": (0, runtime_1.getUserAgent)() };
        const credentials = typeof credentialsValue === "function" ? credentialsValue() : credentialsValue;
        const { url, headers } = yield requestMiddleware({
          url: targetUrl,
          method: method.toUpperCase()
        });
        const authHeader = credentials ? { Authorization: `Key ${credentials}` } : {};
        const requestHeaders = Object.assign(Object.assign(Object.assign(Object.assign({}, authHeader), { Accept: "application/json", "Content-Type": "application/json" }), userAgent), headers !== null && headers !== void 0 ? headers : {});
        const { responseHandler: customResponseHandler } = options, requestInit = __rest(options, ["responseHandler"]);
        const response = yield fetch2(url, Object.assign(Object.assign(Object.assign(Object.assign({}, requestInit), { method, headers: Object.assign(Object.assign({}, requestHeaders), (_a = requestInit.headers) !== null && _a !== void 0 ? _a : {}) }), !isCloudflareWorkers && { mode: "cors" }), { body: method.toLowerCase() !== "get" && input ? JSON.stringify(input) : void 0 }));
        const handleResponse = customResponseHandler !== null && customResponseHandler !== void 0 ? customResponseHandler : responseHandler;
        return yield handleResponse(response);
      });
    }
  }
});

// node_modules/@fal-ai/serverless-client/src/utils.js
var require_utils = __commonJS({
  "node_modules/@fal-ai/serverless-client/src/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ensureAppIdFormat = ensureAppIdFormat;
    exports.parseAppId = parseAppId;
    exports.isValidUrl = isValidUrl;
    exports.throttle = throttle;
    exports.isReact = isReact;
    exports.isPlainObject = isPlainObject;
    function ensureAppIdFormat(id) {
      const parts = id.split("/");
      if (parts.length > 1) {
        return id;
      }
      const [, appOwner, appId] = /^([0-9]+)-([a-zA-Z0-9-]+)$/.exec(id) || [];
      if (appOwner && appId) {
        return `${appOwner}/${appId}`;
      }
      throw new Error(`Invalid app id: ${id}. Must be in the format <appOwner>/<appId>`);
    }
    var APP_NAMESPACES = ["workflows", "comfy"];
    function parseAppId(id) {
      const normalizedId = ensureAppIdFormat(id);
      const parts = normalizedId.split("/");
      if (APP_NAMESPACES.includes(parts[0])) {
        return {
          owner: parts[1],
          alias: parts[2],
          path: parts.slice(3).join("/") || void 0,
          namespace: parts[0]
        };
      }
      return {
        owner: parts[0],
        alias: parts[1],
        path: parts.slice(2).join("/") || void 0
      };
    }
    function isValidUrl(url) {
      try {
        const { host } = new URL(url);
        return /(fal\.(ai|run))$/.test(host);
      } catch (_) {
        return false;
      }
    }
    function throttle(func, limit, leading = false) {
      let lastFunc;
      let lastRan;
      return (...args) => {
        if (!lastRan && leading) {
          func(...args);
          lastRan = Date.now();
        } else {
          if (lastFunc) {
            clearTimeout(lastFunc);
          }
          lastFunc = setTimeout(() => {
            if (Date.now() - lastRan >= limit) {
              func(...args);
              lastRan = Date.now();
            }
          }, limit - (Date.now() - lastRan));
        }
      };
    }
    var isRunningInReact;
    function isReact() {
      if (isRunningInReact === void 0) {
        const stack = new Error().stack;
        isRunningInReact = !!stack && (stack.includes("node_modules/react-dom/") || stack.includes("node_modules/next/"));
      }
      return isRunningInReact;
    }
    function isPlainObject(value) {
      return !!value && Object.getPrototypeOf(value) === Object.prototype;
    }
  }
});

// node_modules/@fal-ai/serverless-client/src/storage.js
var require_storage = __commonJS({
  "node_modules/@fal-ai/serverless-client/src/storage.js"(exports) {
    "use strict";
    var __awaiter3 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storageImpl = void 0;
    var config_1 = require_config();
    var request_1 = require_request();
    var utils_1 = require_utils();
    function getExtensionFromContentType(contentType) {
      var _a;
      const [_, fileType] = contentType.split("/");
      return (_a = fileType.split(/[-;]/)[0]) !== null && _a !== void 0 ? _a : "bin";
    }
    function initiateUpload(file) {
      return __awaiter3(this, void 0, void 0, function* () {
        const contentType = file.type || "application/octet-stream";
        const filename = file.name || `${Date.now()}.${getExtensionFromContentType(contentType)}`;
        return yield (0, request_1.dispatchRequest)("POST", `${(0, config_1.getRestApiUrl)()}/storage/upload/initiate`, {
          content_type: contentType,
          file_name: filename
        });
      });
    }
    exports.storageImpl = {
      upload: (file) => __awaiter3(void 0, void 0, void 0, function* () {
        const { fetch: fetch2 } = (0, config_1.getConfig)();
        const { upload_url: uploadUrl, file_url: url } = yield initiateUpload(file);
        const response = yield fetch2(uploadUrl, {
          method: "PUT",
          body: file,
          headers: {
            "Content-Type": file.type || "application/octet-stream"
          }
        });
        const { responseHandler } = (0, config_1.getConfig)();
        yield responseHandler(response);
        return url;
      }),
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      transformInput: (input) => __awaiter3(void 0, void 0, void 0, function* () {
        if (Array.isArray(input)) {
          return Promise.all(input.map((item) => exports.storageImpl.transformInput(item)));
        } else if (input instanceof Blob) {
          return yield exports.storageImpl.upload(input);
        } else if ((0, utils_1.isPlainObject)(input)) {
          const inputObject = input;
          const promises = Object.entries(inputObject).map((_a) => __awaiter3(void 0, [_a], void 0, function* ([key, value]) {
            return [key, yield exports.storageImpl.transformInput(value)];
          }));
          const results = yield Promise.all(promises);
          return Object.fromEntries(results);
        }
        return input;
      })
    };
  }
});

// node_modules/eventsource-parser/dist/index.cjs
var require_dist = __commonJS({
  "node_modules/eventsource-parser/dist/index.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function createParser(onParse) {
      let isFirstChunk;
      let buffer;
      let startingPosition;
      let startingFieldLength;
      let eventId;
      let eventName;
      let data;
      reset();
      return {
        feed,
        reset
      };
      function reset() {
        isFirstChunk = true;
        buffer = "";
        startingPosition = 0;
        startingFieldLength = -1;
        eventId = void 0;
        eventName = void 0;
        data = "";
      }
      function feed(chunk) {
        buffer = buffer ? buffer + chunk : chunk;
        if (isFirstChunk && hasBom(buffer)) {
          buffer = buffer.slice(BOM.length);
        }
        isFirstChunk = false;
        const length = buffer.length;
        let position = 0;
        let discardTrailingNewline = false;
        while (position < length) {
          if (discardTrailingNewline) {
            if (buffer[position] === "\n") {
              ++position;
            }
            discardTrailingNewline = false;
          }
          let lineLength = -1;
          let fieldLength = startingFieldLength;
          let character;
          for (let index = startingPosition; lineLength < 0 && index < length; ++index) {
            character = buffer[index];
            if (character === ":" && fieldLength < 0) {
              fieldLength = index - position;
            } else if (character === "\r") {
              discardTrailingNewline = true;
              lineLength = index - position;
            } else if (character === "\n") {
              lineLength = index - position;
            }
          }
          if (lineLength < 0) {
            startingPosition = length - position;
            startingFieldLength = fieldLength;
            break;
          } else {
            startingPosition = 0;
            startingFieldLength = -1;
          }
          parseEventStreamLine(buffer, position, fieldLength, lineLength);
          position += lineLength + 1;
        }
        if (position === length) {
          buffer = "";
        } else if (position > 0) {
          buffer = buffer.slice(position);
        }
      }
      function parseEventStreamLine(lineBuffer, index, fieldLength, lineLength) {
        if (lineLength === 0) {
          if (data.length > 0) {
            onParse({
              type: "event",
              id: eventId,
              event: eventName || void 0,
              data: data.slice(0, -1)
              // remove trailing newline
            });
            data = "";
            eventId = void 0;
          }
          eventName = void 0;
          return;
        }
        const noValue = fieldLength < 0;
        const field = lineBuffer.slice(index, index + (noValue ? lineLength : fieldLength));
        let step = 0;
        if (noValue) {
          step = lineLength;
        } else if (lineBuffer[index + fieldLength + 1] === " ") {
          step = fieldLength + 2;
        } else {
          step = fieldLength + 1;
        }
        const position = index + step;
        const valueLength = lineLength - step;
        const value = lineBuffer.slice(position, position + valueLength).toString();
        if (field === "data") {
          data += value ? "".concat(value, "\n") : "\n";
        } else if (field === "event") {
          eventName = value;
        } else if (field === "id" && !value.includes("\0")) {
          eventId = value;
        } else if (field === "retry") {
          const retry = parseInt(value, 10);
          if (!Number.isNaN(retry)) {
            onParse({
              type: "reconnect-interval",
              value: retry
            });
          }
        }
      }
    }
    var BOM = [239, 187, 191];
    function hasBom(buffer) {
      return BOM.every((charCode, index) => buffer.charCodeAt(index) === charCode);
    }
    exports.createParser = createParser;
  }
});

// node_modules/@fal-ai/serverless-client/src/auth.js
var require_auth = __commonJS({
  "node_modules/@fal-ai/serverless-client/src/auth.js"(exports) {
    "use strict";
    var __awaiter3 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TOKEN_EXPIRATION_SECONDS = void 0;
    exports.getTemporaryAuthToken = getTemporaryAuthToken;
    var config_1 = require_config();
    var request_1 = require_request();
    var utils_1 = require_utils();
    exports.TOKEN_EXPIRATION_SECONDS = 120;
    function getTemporaryAuthToken(app) {
      return __awaiter3(this, void 0, void 0, function* () {
        const appId = (0, utils_1.parseAppId)(app);
        const token = yield (0, request_1.dispatchRequest)("POST", `${(0, config_1.getRestApiUrl)()}/tokens/`, {
          allowed_apps: [appId.alias],
          token_expiration: exports.TOKEN_EXPIRATION_SECONDS
        });
        if (typeof token !== "string" && token["detail"]) {
          return token["detail"];
        }
        return token;
      });
    }
  }
});

// node_modules/@fal-ai/serverless-client/src/streaming.js
var require_streaming = __commonJS({
  "node_modules/@fal-ai/serverless-client/src/streaming.js"(exports) {
    "use strict";
    var __awaiter3 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __await3 = exports && exports.__await || function(v) {
      return this instanceof __await3 ? (this.v = v, this) : new __await3(v);
    };
    var __asyncGenerator3 = exports && exports.__asyncGenerator || function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = {}, verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function awaitReturn(f) {
        return function(v) {
          return Promise.resolve(v).then(f, reject);
        };
      }
      function verb(n, f) {
        if (g[n]) {
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
          if (f) i[n] = f(i[n]);
        }
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await3 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FalStream = void 0;
    exports.stream = stream;
    var eventsource_parser_1 = require_dist();
    var auth_1 = require_auth();
    var config_1 = require_config();
    var function_1 = require_function();
    var request_1 = require_request();
    var response_1 = require_response();
    var storage_1 = require_storage();
    var CONTENT_TYPE_EVENT_STREAM = "text/event-stream";
    var EVENT_STREAM_TIMEOUT = 15 * 1e3;
    var FalStream = class {
      constructor(endpointId, options) {
        var _a;
        this.listeners = /* @__PURE__ */ new Map();
        this.buffer = [];
        this.currentData = void 0;
        this.lastEventTimestamp = 0;
        this.streamClosed = false;
        this.abortController = new AbortController();
        this.start = () => __awaiter3(this, void 0, void 0, function* () {
          var _a2, _b;
          const { endpointId: endpointId2, options: options2 } = this;
          const { input, method = "post", connectionMode = "server" } = options2;
          try {
            if (connectionMode === "client") {
              const token = yield (0, auth_1.getTemporaryAuthToken)(endpointId2);
              const { fetch: fetch2 } = (0, config_1.getConfig)();
              const parsedUrl = new URL(this.url);
              parsedUrl.searchParams.set("fal_jwt_token", token);
              const response = yield fetch2(parsedUrl.toString(), {
                method: method.toUpperCase(),
                headers: {
                  accept: (_a2 = options2.accept) !== null && _a2 !== void 0 ? _a2 : CONTENT_TYPE_EVENT_STREAM,
                  "content-type": "application/json"
                },
                body: input && method !== "get" ? JSON.stringify(input) : void 0,
                signal: this.abortController.signal
              });
              return yield this.handleResponse(response);
            }
            return yield (0, request_1.dispatchRequest)(method.toUpperCase(), this.url, input, {
              headers: {
                accept: (_b = options2.accept) !== null && _b !== void 0 ? _b : CONTENT_TYPE_EVENT_STREAM
              },
              responseHandler: this.handleResponse,
              signal: this.abortController.signal
            });
          } catch (error) {
            this.handleError(error);
          }
        });
        this.handleResponse = (response) => __awaiter3(this, void 0, void 0, function* () {
          var _a2;
          if (!response.ok) {
            try {
              yield (0, response_1.defaultResponseHandler)(response);
            } catch (error) {
              this.emit("error", error);
            }
            return;
          }
          const body = response.body;
          if (!body) {
            this.emit("error", new response_1.ApiError({
              message: "Response body is empty.",
              status: 400,
              body: void 0
            }));
            return;
          }
          const isEventStream = response.headers.get("content-type").startsWith(CONTENT_TYPE_EVENT_STREAM);
          if (!isEventStream) {
            const reader2 = body.getReader();
            const emitRawChunk = () => {
              reader2.read().then(({ done, value }) => {
                if (done) {
                  this.emit("done", this.currentData);
                  return;
                }
                this.currentData = value;
                this.emit("data", value);
                emitRawChunk();
              });
            };
            emitRawChunk();
            return;
          }
          const decoder = new TextDecoder("utf-8");
          const reader = response.body.getReader();
          const parser = (0, eventsource_parser_1.createParser)((event) => {
            if (event.type === "event") {
              const data = event.data;
              try {
                const parsedData = JSON.parse(data);
                this.buffer.push(parsedData);
                this.currentData = parsedData;
                this.emit("data", parsedData);
                this.emit("message", parsedData);
              } catch (e) {
                this.emit("error", e);
              }
            }
          });
          const timeout = (_a2 = this.options.timeout) !== null && _a2 !== void 0 ? _a2 : EVENT_STREAM_TIMEOUT;
          const readPartialResponse = () => __awaiter3(this, void 0, void 0, function* () {
            const { value, done } = yield reader.read();
            this.lastEventTimestamp = Date.now();
            parser.feed(decoder.decode(value));
            if (Date.now() - this.lastEventTimestamp > timeout) {
              this.emit("error", new response_1.ApiError({
                message: `Event stream timed out after ${(timeout / 1e3).toFixed(0)} seconds with no messages.`,
                status: 408
              }));
            }
            if (!done) {
              readPartialResponse().catch(this.handleError);
            } else {
              this.emit("done", this.currentData);
            }
          });
          readPartialResponse().catch(this.handleError);
          return;
        });
        this.handleError = (error) => {
          var _a2;
          const apiError = error instanceof response_1.ApiError ? error : new response_1.ApiError({
            message: (_a2 = error.message) !== null && _a2 !== void 0 ? _a2 : "An unknown error occurred",
            status: 500
          });
          this.emit("error", apiError);
          return;
        };
        this.on = (type, listener) => {
          var _a2;
          if (!this.listeners.has(type)) {
            this.listeners.set(type, []);
          }
          (_a2 = this.listeners.get(type)) === null || _a2 === void 0 ? void 0 : _a2.push(listener);
        };
        this.emit = (type, event) => {
          const listeners = this.listeners.get(type) || [];
          for (const listener of listeners) {
            listener(event);
          }
        };
        this.done = () => __awaiter3(this, void 0, void 0, function* () {
          return this.donePromise;
        });
        this.abort = () => {
          this.abortController.abort();
        };
        this.endpointId = endpointId;
        this.url = (_a = options.url) !== null && _a !== void 0 ? _a : (0, function_1.buildUrl)(endpointId, {
          path: "/stream",
          query: options.queryParams
        });
        this.options = options;
        this.donePromise = new Promise((resolve, reject) => {
          if (this.streamClosed) {
            reject(new response_1.ApiError({
              message: "Streaming connection is already closed.",
              status: 400,
              body: void 0
            }));
          }
          this.on("done", (data) => {
            this.streamClosed = true;
            resolve(data);
          });
          this.on("error", (error) => {
            this.streamClosed = true;
            reject(error);
          });
        });
        this.start().catch(this.handleError);
      }
      [Symbol.asyncIterator]() {
        return __asyncGenerator3(this, arguments, function* _a() {
          let running = true;
          const stopAsyncIterator = () => running = false;
          this.on("error", stopAsyncIterator);
          this.on("done", stopAsyncIterator);
          while (running) {
            const data = this.buffer.shift();
            if (data) {
              yield yield __await3(data);
            }
            yield __await3(new Promise((resolve) => setTimeout(resolve, 16)));
          }
        });
      }
    };
    exports.FalStream = FalStream;
    function stream(endpointId, options) {
      return __awaiter3(this, void 0, void 0, function* () {
        const input = options.input && options.autoUpload !== false ? yield storage_1.storageImpl.transformInput(options.input) : options.input;
        return new FalStream(endpointId, Object.assign(Object.assign({}, options), { input }));
      });
    }
  }
});

// node_modules/@fal-ai/serverless-client/src/function.js
var require_function = __commonJS({
  "node_modules/@fal-ai/serverless-client/src/function.js"(exports) {
    "use strict";
    var __awaiter3 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __rest = exports && exports.__rest || function(s, e) {
      var t = {};
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.queue = void 0;
    exports.buildUrl = buildUrl;
    exports.send = send;
    exports.run = run;
    exports.subscribe = subscribe;
    var request_1 = require_request();
    var storage_1 = require_storage();
    var streaming_1 = require_streaming();
    var utils_1 = require_utils();
    function buildUrl(id, options = {}) {
      var _a, _b;
      const method = ((_a = options.method) !== null && _a !== void 0 ? _a : "post").toLowerCase();
      const path = ((_b = options.path) !== null && _b !== void 0 ? _b : "").replace(/^\//, "").replace(/\/{2,}/, "/");
      const input = options.input;
      const params = Object.assign(Object.assign({}, options.query || {}), method === "get" ? input : {});
      const queryParams = Object.keys(params).length > 0 ? `?${new URLSearchParams(params).toString()}` : "";
      if ((0, utils_1.isValidUrl)(id)) {
        const url2 = id.endsWith("/") ? id : `${id}/`;
        return `${url2}${path}${queryParams}`;
      }
      const appId = (0, utils_1.ensureAppIdFormat)(id);
      const subdomain = options.subdomain ? `${options.subdomain}.` : "";
      const url = `https://${subdomain}fal.run/${appId}/${path}`;
      return `${url.replace(/\/$/, "")}${queryParams}`;
    }
    function send(id_1) {
      return __awaiter3(this, arguments, void 0, function* (id, options = {}) {
        var _a;
        const input = options.input && options.autoUpload !== false ? yield storage_1.storageImpl.transformInput(options.input) : options.input;
        return (0, request_1.dispatchRequest)((_a = options.method) !== null && _a !== void 0 ? _a : "post", buildUrl(id, options), input);
      });
    }
    function run(id_1) {
      return __awaiter3(this, arguments, void 0, function* (id, options = {}) {
        return send(id, options);
      });
    }
    var DEFAULT_POLL_INTERVAL = 500;
    exports.queue = {
      submit(endpointId, options) {
        return __awaiter3(this, void 0, void 0, function* () {
          const { webhookUrl, path = "" } = options, runOptions = __rest(options, ["webhookUrl", "path"]);
          return send(endpointId, Object.assign(Object.assign({}, runOptions), { subdomain: "queue", method: "post", path, query: webhookUrl ? { fal_webhook: webhookUrl } : void 0 }));
        });
      },
      status(endpointId_1, _a) {
        return __awaiter3(this, arguments, void 0, function* (endpointId, { requestId, logs = false }) {
          const appId = (0, utils_1.parseAppId)(endpointId);
          const prefix = appId.namespace ? `${appId.namespace}/` : "";
          return send(`${prefix}${appId.owner}/${appId.alias}`, {
            subdomain: "queue",
            method: "get",
            path: `/requests/${requestId}/status`,
            input: {
              logs: logs ? "1" : "0"
            }
          });
        });
      },
      streamStatus(endpointId_1, _a) {
        return __awaiter3(this, arguments, void 0, function* (endpointId, { requestId, logs = false, connectionMode }) {
          const appId = (0, utils_1.parseAppId)(endpointId);
          const prefix = appId.namespace ? `${appId.namespace}/` : "";
          const queryParams = {
            logs: logs ? "1" : "0"
          };
          const url = buildUrl(`${prefix}${appId.owner}/${appId.alias}`, {
            subdomain: "queue",
            path: `/requests/${requestId}/status/stream`,
            query: queryParams
          });
          return new streaming_1.FalStream(endpointId, {
            url,
            method: "get",
            connectionMode,
            queryParams
          });
        });
      },
      subscribeToStatus(endpointId, options) {
        return __awaiter3(this, void 0, void 0, function* () {
          const requestId = options.requestId;
          const timeout = options.timeout;
          let timeoutId = void 0;
          const handleCancelError = () => {
          };
          if (options.mode === "streaming") {
            const status = yield exports.queue.streamStatus(endpointId, {
              requestId,
              logs: options.logs,
              connectionMode: "connectionMode" in options ? options.connectionMode : void 0
            });
            const logs = [];
            if (timeout) {
              timeoutId = setTimeout(() => {
                status.abort();
                exports.queue.cancel(endpointId, { requestId }).catch(handleCancelError);
                throw new Error(`Client timed out waiting for the request to complete after ${timeout}ms`);
              }, timeout);
            }
            status.on("data", (data) => {
              if (options.onQueueUpdate) {
                if ("logs" in data && Array.isArray(data.logs) && data.logs.length > 0) {
                  logs.push(...data.logs);
                }
                options.onQueueUpdate("logs" in data ? Object.assign(Object.assign({}, data), { logs }) : data);
              }
            });
            const doneStatus = yield status.done();
            if (timeoutId) {
              clearTimeout(timeoutId);
            }
            return doneStatus;
          }
          return new Promise((resolve, reject) => {
            var _a;
            let pollingTimeoutId;
            const pollInterval = "pollInterval" in options && typeof options.pollInterval === "number" ? (_a = options.pollInterval) !== null && _a !== void 0 ? _a : DEFAULT_POLL_INTERVAL : DEFAULT_POLL_INTERVAL;
            const clearScheduledTasks = () => {
              if (timeoutId) {
                clearTimeout(timeoutId);
              }
              if (pollingTimeoutId) {
                clearTimeout(pollingTimeoutId);
              }
            };
            if (timeout) {
              timeoutId = setTimeout(() => {
                clearScheduledTasks();
                exports.queue.cancel(endpointId, { requestId }).catch(handleCancelError);
                reject(new Error(`Client timed out waiting for the request to complete after ${timeout}ms`));
              }, timeout);
            }
            const poll = () => __awaiter3(this, void 0, void 0, function* () {
              var _a2;
              try {
                const requestStatus = yield exports.queue.status(endpointId, {
                  requestId,
                  logs: (_a2 = options.logs) !== null && _a2 !== void 0 ? _a2 : false
                });
                if (options.onQueueUpdate) {
                  options.onQueueUpdate(requestStatus);
                }
                if (requestStatus.status === "COMPLETED") {
                  clearScheduledTasks();
                  resolve(requestStatus);
                  return;
                }
                pollingTimeoutId = setTimeout(poll, pollInterval);
              } catch (error) {
                clearScheduledTasks();
                reject(error);
              }
            });
            poll().catch(reject);
          });
        });
      },
      result(endpointId_1, _a) {
        return __awaiter3(this, arguments, void 0, function* (endpointId, { requestId }) {
          const appId = (0, utils_1.parseAppId)(endpointId);
          const prefix = appId.namespace ? `${appId.namespace}/` : "";
          return send(`${prefix}${appId.owner}/${appId.alias}`, {
            subdomain: "queue",
            method: "get",
            path: `/requests/${requestId}`
          });
        });
      },
      cancel(endpointId_1, _a) {
        return __awaiter3(this, arguments, void 0, function* (endpointId, { requestId }) {
          const appId = (0, utils_1.parseAppId)(endpointId);
          const prefix = appId.namespace ? `${appId.namespace}/` : "";
          yield send(`${prefix}${appId.owner}/${appId.alias}`, {
            subdomain: "queue",
            method: "put",
            path: `/requests/${requestId}/cancel`
          });
        });
      }
    };
    function subscribe(endpointId_1) {
      return __awaiter3(this, arguments, void 0, function* (endpointId, options = {}) {
        const { request_id: requestId } = yield exports.queue.submit(endpointId, options);
        if (options.onEnqueue) {
          options.onEnqueue(requestId);
        }
        yield exports.queue.subscribeToStatus(endpointId, Object.assign({ requestId }, options));
        return exports.queue.result(endpointId, { requestId });
      });
    }
  }
});

// node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs
function utf8Count(str) {
  var strLength = str.length;
  var byteLength = 0;
  var pos = 0;
  while (pos < strLength) {
    var value = str.charCodeAt(pos++);
    if ((value & 4294967168) === 0) {
      byteLength++;
      continue;
    } else if ((value & 4294965248) === 0) {
      byteLength += 2;
    } else {
      if (value >= 55296 && value <= 56319) {
        if (pos < strLength) {
          var extra = str.charCodeAt(pos);
          if ((extra & 64512) === 56320) {
            ++pos;
            value = ((value & 1023) << 10) + (extra & 1023) + 65536;
          }
        }
      }
      if ((value & 4294901760) === 0) {
        byteLength += 3;
      } else {
        byteLength += 4;
      }
    }
  }
  return byteLength;
}
function utf8EncodeJs(str, output, outputOffset) {
  var strLength = str.length;
  var offset = outputOffset;
  var pos = 0;
  while (pos < strLength) {
    var value = str.charCodeAt(pos++);
    if ((value & 4294967168) === 0) {
      output[offset++] = value;
      continue;
    } else if ((value & 4294965248) === 0) {
      output[offset++] = value >> 6 & 31 | 192;
    } else {
      if (value >= 55296 && value <= 56319) {
        if (pos < strLength) {
          var extra = str.charCodeAt(pos);
          if ((extra & 64512) === 56320) {
            ++pos;
            value = ((value & 1023) << 10) + (extra & 1023) + 65536;
          }
        }
      }
      if ((value & 4294901760) === 0) {
        output[offset++] = value >> 12 & 15 | 224;
        output[offset++] = value >> 6 & 63 | 128;
      } else {
        output[offset++] = value >> 18 & 7 | 240;
        output[offset++] = value >> 12 & 63 | 128;
        output[offset++] = value >> 6 & 63 | 128;
      }
    }
    output[offset++] = value & 63 | 128;
  }
}
function utf8EncodeTE(str, output, outputOffset) {
  sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));
}
function utf8Encode(str, output, outputOffset) {
  if (str.length > TEXT_ENCODER_THRESHOLD) {
    utf8EncodeTE(str, output, outputOffset);
  } else {
    utf8EncodeJs(str, output, outputOffset);
  }
}
function utf8DecodeJs(bytes, inputOffset, byteLength) {
  var offset = inputOffset;
  var end = offset + byteLength;
  var units = [];
  var result = "";
  while (offset < end) {
    var byte1 = bytes[offset++];
    if ((byte1 & 128) === 0) {
      units.push(byte1);
    } else if ((byte1 & 224) === 192) {
      var byte2 = bytes[offset++] & 63;
      units.push((byte1 & 31) << 6 | byte2);
    } else if ((byte1 & 240) === 224) {
      var byte2 = bytes[offset++] & 63;
      var byte3 = bytes[offset++] & 63;
      units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);
    } else if ((byte1 & 248) === 240) {
      var byte2 = bytes[offset++] & 63;
      var byte3 = bytes[offset++] & 63;
      var byte4 = bytes[offset++] & 63;
      var unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
      if (unit > 65535) {
        unit -= 65536;
        units.push(unit >>> 10 & 1023 | 55296);
        unit = 56320 | unit & 1023;
      }
      units.push(unit);
    } else {
      units.push(byte1);
    }
    if (units.length >= CHUNK_SIZE) {
      result += String.fromCharCode.apply(String, units);
      units.length = 0;
    }
  }
  if (units.length > 0) {
    result += String.fromCharCode.apply(String, units);
  }
  return result;
}
function utf8DecodeTD(bytes, inputOffset, byteLength) {
  var stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);
  return sharedTextDecoder.decode(stringBytes);
}
function utf8Decode(bytes, inputOffset, byteLength) {
  if (byteLength > TEXT_DECODER_THRESHOLD) {
    return utf8DecodeTD(bytes, inputOffset, byteLength);
  } else {
    return utf8DecodeJs(bytes, inputOffset, byteLength);
  }
}
var sharedTextEncoder, TEXT_ENCODER_THRESHOLD, CHUNK_SIZE, sharedTextDecoder, TEXT_DECODER_THRESHOLD;
var init_utf8 = __esm({
  "node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs"() {
    sharedTextEncoder = new TextEncoder();
    TEXT_ENCODER_THRESHOLD = 50;
    CHUNK_SIZE = 4096;
    sharedTextDecoder = new TextDecoder();
    TEXT_DECODER_THRESHOLD = 200;
  }
});

// node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs
var ExtData;
var init_ExtData = __esm({
  "node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs"() {
    ExtData = /** @class */
    /* @__PURE__ */ function() {
      function ExtData2(type, data) {
        this.type = type;
        this.data = data;
      }
      return ExtData2;
    }();
  }
});

// node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs
var __extends, DecodeError;
var init_DecodeError = __esm({
  "node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs"() {
    __extends = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    DecodeError = /** @class */
    function(_super) {
      __extends(DecodeError2, _super);
      function DecodeError2(message) {
        var _this = _super.call(this, message) || this;
        var proto = Object.create(DecodeError2.prototype);
        Object.setPrototypeOf(_this, proto);
        Object.defineProperty(_this, "name", {
          configurable: true,
          enumerable: false,
          value: DecodeError2.name
        });
        return _this;
      }
      return DecodeError2;
    }(Error);
  }
});

// node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs
function setUint64(view, offset, value) {
  var high = value / 4294967296;
  var low = value;
  view.setUint32(offset, high);
  view.setUint32(offset + 4, low);
}
function setInt64(view, offset, value) {
  var high = Math.floor(value / 4294967296);
  var low = value;
  view.setUint32(offset, high);
  view.setUint32(offset + 4, low);
}
function getInt64(view, offset) {
  var high = view.getInt32(offset);
  var low = view.getUint32(offset + 4);
  return high * 4294967296 + low;
}
function getUint64(view, offset) {
  var high = view.getUint32(offset);
  var low = view.getUint32(offset + 4);
  return high * 4294967296 + low;
}
var UINT32_MAX;
var init_int = __esm({
  "node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs"() {
    UINT32_MAX = 4294967295;
  }
});

// node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs
function encodeTimeSpecToTimestamp(_a) {
  var sec = _a.sec, nsec = _a.nsec;
  if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {
    if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {
      var rv = new Uint8Array(4);
      var view = new DataView(rv.buffer);
      view.setUint32(0, sec);
      return rv;
    } else {
      var secHigh = sec / 4294967296;
      var secLow = sec & 4294967295;
      var rv = new Uint8Array(8);
      var view = new DataView(rv.buffer);
      view.setUint32(0, nsec << 2 | secHigh & 3);
      view.setUint32(4, secLow);
      return rv;
    }
  } else {
    var rv = new Uint8Array(12);
    var view = new DataView(rv.buffer);
    view.setUint32(0, nsec);
    setInt64(view, 4, sec);
    return rv;
  }
}
function encodeDateToTimeSpec(date) {
  var msec = date.getTime();
  var sec = Math.floor(msec / 1e3);
  var nsec = (msec - sec * 1e3) * 1e6;
  var nsecInSec = Math.floor(nsec / 1e9);
  return {
    sec: sec + nsecInSec,
    nsec: nsec - nsecInSec * 1e9
  };
}
function encodeTimestampExtension(object) {
  if (object instanceof Date) {
    var timeSpec = encodeDateToTimeSpec(object);
    return encodeTimeSpecToTimestamp(timeSpec);
  } else {
    return null;
  }
}
function decodeTimestampToTimeSpec(data) {
  var view = new DataView(data.buffer, data.byteOffset, data.byteLength);
  switch (data.byteLength) {
    case 4: {
      var sec = view.getUint32(0);
      var nsec = 0;
      return { sec, nsec };
    }
    case 8: {
      var nsec30AndSecHigh2 = view.getUint32(0);
      var secLow32 = view.getUint32(4);
      var sec = (nsec30AndSecHigh2 & 3) * 4294967296 + secLow32;
      var nsec = nsec30AndSecHigh2 >>> 2;
      return { sec, nsec };
    }
    case 12: {
      var sec = getInt64(view, 4);
      var nsec = view.getUint32(0);
      return { sec, nsec };
    }
    default:
      throw new DecodeError("Unrecognized data size for timestamp (expected 4, 8, or 12): ".concat(data.length));
  }
}
function decodeTimestampExtension(data) {
  var timeSpec = decodeTimestampToTimeSpec(data);
  return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);
}
var EXT_TIMESTAMP, TIMESTAMP32_MAX_SEC, TIMESTAMP64_MAX_SEC, timestampExtension;
var init_timestamp = __esm({
  "node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs"() {
    init_DecodeError();
    init_int();
    EXT_TIMESTAMP = -1;
    TIMESTAMP32_MAX_SEC = 4294967296 - 1;
    TIMESTAMP64_MAX_SEC = 17179869184 - 1;
    timestampExtension = {
      type: EXT_TIMESTAMP,
      encode: encodeTimestampExtension,
      decode: decodeTimestampExtension
    };
  }
});

// node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs
var ExtensionCodec;
var init_ExtensionCodec = __esm({
  "node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs"() {
    init_ExtData();
    init_timestamp();
    ExtensionCodec = /** @class */
    function() {
      function ExtensionCodec2() {
        this.builtInEncoders = [];
        this.builtInDecoders = [];
        this.encoders = [];
        this.decoders = [];
        this.register(timestampExtension);
      }
      ExtensionCodec2.prototype.register = function(_a) {
        var type = _a.type, encode2 = _a.encode, decode2 = _a.decode;
        if (type >= 0) {
          this.encoders[type] = encode2;
          this.decoders[type] = decode2;
        } else {
          var index = 1 + type;
          this.builtInEncoders[index] = encode2;
          this.builtInDecoders[index] = decode2;
        }
      };
      ExtensionCodec2.prototype.tryToEncode = function(object, context) {
        for (var i = 0; i < this.builtInEncoders.length; i++) {
          var encodeExt = this.builtInEncoders[i];
          if (encodeExt != null) {
            var data = encodeExt(object, context);
            if (data != null) {
              var type = -1 - i;
              return new ExtData(type, data);
            }
          }
        }
        for (var i = 0; i < this.encoders.length; i++) {
          var encodeExt = this.encoders[i];
          if (encodeExt != null) {
            var data = encodeExt(object, context);
            if (data != null) {
              var type = i;
              return new ExtData(type, data);
            }
          }
        }
        if (object instanceof ExtData) {
          return object;
        }
        return null;
      };
      ExtensionCodec2.prototype.decode = function(data, type, context) {
        var decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];
        if (decodeExt) {
          return decodeExt(data, type, context);
        } else {
          return new ExtData(type, data);
        }
      };
      ExtensionCodec2.defaultCodec = new ExtensionCodec2();
      return ExtensionCodec2;
    }();
  }
});

// node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs
function ensureUint8Array(buffer) {
  if (buffer instanceof Uint8Array) {
    return buffer;
  } else if (ArrayBuffer.isView(buffer)) {
    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
  } else if (buffer instanceof ArrayBuffer) {
    return new Uint8Array(buffer);
  } else {
    return Uint8Array.from(buffer);
  }
}
function createDataView(buffer) {
  if (buffer instanceof ArrayBuffer) {
    return new DataView(buffer);
  }
  var bufferView = ensureUint8Array(buffer);
  return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);
}
var init_typedArrays = __esm({
  "node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs"() {
  }
});

// node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs
var DEFAULT_MAX_DEPTH, DEFAULT_INITIAL_BUFFER_SIZE, Encoder;
var init_Encoder = __esm({
  "node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs"() {
    init_utf8();
    init_ExtensionCodec();
    init_int();
    init_typedArrays();
    DEFAULT_MAX_DEPTH = 100;
    DEFAULT_INITIAL_BUFFER_SIZE = 2048;
    Encoder = /** @class */
    function() {
      function Encoder2(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        this.extensionCodec = (_a = options === null || options === void 0 ? void 0 : options.extensionCodec) !== null && _a !== void 0 ? _a : ExtensionCodec.defaultCodec;
        this.context = options === null || options === void 0 ? void 0 : options.context;
        this.useBigInt64 = (_b = options === null || options === void 0 ? void 0 : options.useBigInt64) !== null && _b !== void 0 ? _b : false;
        this.maxDepth = (_c = options === null || options === void 0 ? void 0 : options.maxDepth) !== null && _c !== void 0 ? _c : DEFAULT_MAX_DEPTH;
        this.initialBufferSize = (_d = options === null || options === void 0 ? void 0 : options.initialBufferSize) !== null && _d !== void 0 ? _d : DEFAULT_INITIAL_BUFFER_SIZE;
        this.sortKeys = (_e = options === null || options === void 0 ? void 0 : options.sortKeys) !== null && _e !== void 0 ? _e : false;
        this.forceFloat32 = (_f = options === null || options === void 0 ? void 0 : options.forceFloat32) !== null && _f !== void 0 ? _f : false;
        this.ignoreUndefined = (_g = options === null || options === void 0 ? void 0 : options.ignoreUndefined) !== null && _g !== void 0 ? _g : false;
        this.forceIntegerToFloat = (_h = options === null || options === void 0 ? void 0 : options.forceIntegerToFloat) !== null && _h !== void 0 ? _h : false;
        this.pos = 0;
        this.view = new DataView(new ArrayBuffer(this.initialBufferSize));
        this.bytes = new Uint8Array(this.view.buffer);
      }
      Encoder2.prototype.reinitializeState = function() {
        this.pos = 0;
      };
      Encoder2.prototype.encodeSharedRef = function(object) {
        this.reinitializeState();
        this.doEncode(object, 1);
        return this.bytes.subarray(0, this.pos);
      };
      Encoder2.prototype.encode = function(object) {
        this.reinitializeState();
        this.doEncode(object, 1);
        return this.bytes.slice(0, this.pos);
      };
      Encoder2.prototype.doEncode = function(object, depth) {
        if (depth > this.maxDepth) {
          throw new Error("Too deep objects in depth ".concat(depth));
        }
        if (object == null) {
          this.encodeNil();
        } else if (typeof object === "boolean") {
          this.encodeBoolean(object);
        } else if (typeof object === "number") {
          if (!this.forceIntegerToFloat) {
            this.encodeNumber(object);
          } else {
            this.encodeNumberAsFloat(object);
          }
        } else if (typeof object === "string") {
          this.encodeString(object);
        } else if (this.useBigInt64 && typeof object === "bigint") {
          this.encodeBigInt64(object);
        } else {
          this.encodeObject(object, depth);
        }
      };
      Encoder2.prototype.ensureBufferSizeToWrite = function(sizeToWrite) {
        var requiredSize = this.pos + sizeToWrite;
        if (this.view.byteLength < requiredSize) {
          this.resizeBuffer(requiredSize * 2);
        }
      };
      Encoder2.prototype.resizeBuffer = function(newSize) {
        var newBuffer = new ArrayBuffer(newSize);
        var newBytes = new Uint8Array(newBuffer);
        var newView = new DataView(newBuffer);
        newBytes.set(this.bytes);
        this.view = newView;
        this.bytes = newBytes;
      };
      Encoder2.prototype.encodeNil = function() {
        this.writeU8(192);
      };
      Encoder2.prototype.encodeBoolean = function(object) {
        if (object === false) {
          this.writeU8(194);
        } else {
          this.writeU8(195);
        }
      };
      Encoder2.prototype.encodeNumber = function(object) {
        if (!this.forceIntegerToFloat && Number.isSafeInteger(object)) {
          if (object >= 0) {
            if (object < 128) {
              this.writeU8(object);
            } else if (object < 256) {
              this.writeU8(204);
              this.writeU8(object);
            } else if (object < 65536) {
              this.writeU8(205);
              this.writeU16(object);
            } else if (object < 4294967296) {
              this.writeU8(206);
              this.writeU32(object);
            } else if (!this.useBigInt64) {
              this.writeU8(207);
              this.writeU64(object);
            } else {
              this.encodeNumberAsFloat(object);
            }
          } else {
            if (object >= -32) {
              this.writeU8(224 | object + 32);
            } else if (object >= -128) {
              this.writeU8(208);
              this.writeI8(object);
            } else if (object >= -32768) {
              this.writeU8(209);
              this.writeI16(object);
            } else if (object >= -2147483648) {
              this.writeU8(210);
              this.writeI32(object);
            } else if (!this.useBigInt64) {
              this.writeU8(211);
              this.writeI64(object);
            } else {
              this.encodeNumberAsFloat(object);
            }
          }
        } else {
          this.encodeNumberAsFloat(object);
        }
      };
      Encoder2.prototype.encodeNumberAsFloat = function(object) {
        if (this.forceFloat32) {
          this.writeU8(202);
          this.writeF32(object);
        } else {
          this.writeU8(203);
          this.writeF64(object);
        }
      };
      Encoder2.prototype.encodeBigInt64 = function(object) {
        if (object >= BigInt(0)) {
          this.writeU8(207);
          this.writeBigUint64(object);
        } else {
          this.writeU8(211);
          this.writeBigInt64(object);
        }
      };
      Encoder2.prototype.writeStringHeader = function(byteLength) {
        if (byteLength < 32) {
          this.writeU8(160 + byteLength);
        } else if (byteLength < 256) {
          this.writeU8(217);
          this.writeU8(byteLength);
        } else if (byteLength < 65536) {
          this.writeU8(218);
          this.writeU16(byteLength);
        } else if (byteLength < 4294967296) {
          this.writeU8(219);
          this.writeU32(byteLength);
        } else {
          throw new Error("Too long string: ".concat(byteLength, " bytes in UTF-8"));
        }
      };
      Encoder2.prototype.encodeString = function(object) {
        var maxHeaderSize = 1 + 4;
        var byteLength = utf8Count(object);
        this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);
        this.writeStringHeader(byteLength);
        utf8Encode(object, this.bytes, this.pos);
        this.pos += byteLength;
      };
      Encoder2.prototype.encodeObject = function(object, depth) {
        var ext = this.extensionCodec.tryToEncode(object, this.context);
        if (ext != null) {
          this.encodeExtension(ext);
        } else if (Array.isArray(object)) {
          this.encodeArray(object, depth);
        } else if (ArrayBuffer.isView(object)) {
          this.encodeBinary(object);
        } else if (typeof object === "object") {
          this.encodeMap(object, depth);
        } else {
          throw new Error("Unrecognized object: ".concat(Object.prototype.toString.apply(object)));
        }
      };
      Encoder2.prototype.encodeBinary = function(object) {
        var size = object.byteLength;
        if (size < 256) {
          this.writeU8(196);
          this.writeU8(size);
        } else if (size < 65536) {
          this.writeU8(197);
          this.writeU16(size);
        } else if (size < 4294967296) {
          this.writeU8(198);
          this.writeU32(size);
        } else {
          throw new Error("Too large binary: ".concat(size));
        }
        var bytes = ensureUint8Array(object);
        this.writeU8a(bytes);
      };
      Encoder2.prototype.encodeArray = function(object, depth) {
        var size = object.length;
        if (size < 16) {
          this.writeU8(144 + size);
        } else if (size < 65536) {
          this.writeU8(220);
          this.writeU16(size);
        } else if (size < 4294967296) {
          this.writeU8(221);
          this.writeU32(size);
        } else {
          throw new Error("Too large array: ".concat(size));
        }
        for (var _i = 0, object_1 = object; _i < object_1.length; _i++) {
          var item = object_1[_i];
          this.doEncode(item, depth + 1);
        }
      };
      Encoder2.prototype.countWithoutUndefined = function(object, keys) {
        var count = 0;
        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
          var key = keys_1[_i];
          if (object[key] !== void 0) {
            count++;
          }
        }
        return count;
      };
      Encoder2.prototype.encodeMap = function(object, depth) {
        var keys = Object.keys(object);
        if (this.sortKeys) {
          keys.sort();
        }
        var size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;
        if (size < 16) {
          this.writeU8(128 + size);
        } else if (size < 65536) {
          this.writeU8(222);
          this.writeU16(size);
        } else if (size < 4294967296) {
          this.writeU8(223);
          this.writeU32(size);
        } else {
          throw new Error("Too large map object: ".concat(size));
        }
        for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {
          var key = keys_2[_i];
          var value = object[key];
          if (!(this.ignoreUndefined && value === void 0)) {
            this.encodeString(key);
            this.doEncode(value, depth + 1);
          }
        }
      };
      Encoder2.prototype.encodeExtension = function(ext) {
        var size = ext.data.length;
        if (size === 1) {
          this.writeU8(212);
        } else if (size === 2) {
          this.writeU8(213);
        } else if (size === 4) {
          this.writeU8(214);
        } else if (size === 8) {
          this.writeU8(215);
        } else if (size === 16) {
          this.writeU8(216);
        } else if (size < 256) {
          this.writeU8(199);
          this.writeU8(size);
        } else if (size < 65536) {
          this.writeU8(200);
          this.writeU16(size);
        } else if (size < 4294967296) {
          this.writeU8(201);
          this.writeU32(size);
        } else {
          throw new Error("Too large extension object: ".concat(size));
        }
        this.writeI8(ext.type);
        this.writeU8a(ext.data);
      };
      Encoder2.prototype.writeU8 = function(value) {
        this.ensureBufferSizeToWrite(1);
        this.view.setUint8(this.pos, value);
        this.pos++;
      };
      Encoder2.prototype.writeU8a = function(values) {
        var size = values.length;
        this.ensureBufferSizeToWrite(size);
        this.bytes.set(values, this.pos);
        this.pos += size;
      };
      Encoder2.prototype.writeI8 = function(value) {
        this.ensureBufferSizeToWrite(1);
        this.view.setInt8(this.pos, value);
        this.pos++;
      };
      Encoder2.prototype.writeU16 = function(value) {
        this.ensureBufferSizeToWrite(2);
        this.view.setUint16(this.pos, value);
        this.pos += 2;
      };
      Encoder2.prototype.writeI16 = function(value) {
        this.ensureBufferSizeToWrite(2);
        this.view.setInt16(this.pos, value);
        this.pos += 2;
      };
      Encoder2.prototype.writeU32 = function(value) {
        this.ensureBufferSizeToWrite(4);
        this.view.setUint32(this.pos, value);
        this.pos += 4;
      };
      Encoder2.prototype.writeI32 = function(value) {
        this.ensureBufferSizeToWrite(4);
        this.view.setInt32(this.pos, value);
        this.pos += 4;
      };
      Encoder2.prototype.writeF32 = function(value) {
        this.ensureBufferSizeToWrite(4);
        this.view.setFloat32(this.pos, value);
        this.pos += 4;
      };
      Encoder2.prototype.writeF64 = function(value) {
        this.ensureBufferSizeToWrite(8);
        this.view.setFloat64(this.pos, value);
        this.pos += 8;
      };
      Encoder2.prototype.writeU64 = function(value) {
        this.ensureBufferSizeToWrite(8);
        setUint64(this.view, this.pos, value);
        this.pos += 8;
      };
      Encoder2.prototype.writeI64 = function(value) {
        this.ensureBufferSizeToWrite(8);
        setInt64(this.view, this.pos, value);
        this.pos += 8;
      };
      Encoder2.prototype.writeBigUint64 = function(value) {
        this.ensureBufferSizeToWrite(8);
        this.view.setBigUint64(this.pos, value);
        this.pos += 8;
      };
      Encoder2.prototype.writeBigInt64 = function(value) {
        this.ensureBufferSizeToWrite(8);
        this.view.setBigInt64(this.pos, value);
        this.pos += 8;
      };
      return Encoder2;
    }();
  }
});

// node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs
function encode(value, options) {
  var encoder = new Encoder(options);
  return encoder.encodeSharedRef(value);
}
var init_encode = __esm({
  "node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs"() {
    init_Encoder();
  }
});

// node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs
function prettyByte(byte) {
  return "".concat(byte < 0 ? "-" : "", "0x").concat(Math.abs(byte).toString(16).padStart(2, "0"));
}
var init_prettyByte = __esm({
  "node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs"() {
  }
});

// node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs
var DEFAULT_MAX_KEY_LENGTH, DEFAULT_MAX_LENGTH_PER_KEY, CachedKeyDecoder;
var init_CachedKeyDecoder = __esm({
  "node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs"() {
    init_utf8();
    DEFAULT_MAX_KEY_LENGTH = 16;
    DEFAULT_MAX_LENGTH_PER_KEY = 16;
    CachedKeyDecoder = /** @class */
    function() {
      function CachedKeyDecoder2(maxKeyLength, maxLengthPerKey) {
        if (maxKeyLength === void 0) {
          maxKeyLength = DEFAULT_MAX_KEY_LENGTH;
        }
        if (maxLengthPerKey === void 0) {
          maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY;
        }
        this.maxKeyLength = maxKeyLength;
        this.maxLengthPerKey = maxLengthPerKey;
        this.hit = 0;
        this.miss = 0;
        this.caches = [];
        for (var i = 0; i < this.maxKeyLength; i++) {
          this.caches.push([]);
        }
      }
      CachedKeyDecoder2.prototype.canBeCached = function(byteLength) {
        return byteLength > 0 && byteLength <= this.maxKeyLength;
      };
      CachedKeyDecoder2.prototype.find = function(bytes, inputOffset, byteLength) {
        var records = this.caches[byteLength - 1];
        FIND_CHUNK: for (var _i = 0, records_1 = records; _i < records_1.length; _i++) {
          var record = records_1[_i];
          var recordBytes = record.bytes;
          for (var j = 0; j < byteLength; j++) {
            if (recordBytes[j] !== bytes[inputOffset + j]) {
              continue FIND_CHUNK;
            }
          }
          return record.str;
        }
        return null;
      };
      CachedKeyDecoder2.prototype.store = function(bytes, value) {
        var records = this.caches[bytes.length - 1];
        var record = { bytes, str: value };
        if (records.length >= this.maxLengthPerKey) {
          records[Math.random() * records.length | 0] = record;
        } else {
          records.push(record);
        }
      };
      CachedKeyDecoder2.prototype.decode = function(bytes, inputOffset, byteLength) {
        var cachedValue = this.find(bytes, inputOffset, byteLength);
        if (cachedValue != null) {
          this.hit++;
          return cachedValue;
        }
        this.miss++;
        var str = utf8DecodeJs(bytes, inputOffset, byteLength);
        var slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);
        this.store(slicedCopyOfBytes, str);
        return str;
      };
      return CachedKeyDecoder2;
    }();
  }
});

// node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs
var __awaiter, __generator, __asyncValues, __await, __asyncGenerator, STATE_ARRAY, STATE_MAP_KEY, STATE_MAP_VALUE, isValidMapKeyType, HEAD_BYTE_REQUIRED, EMPTY_VIEW, EMPTY_BYTES, DataViewIndexOutOfBoundsError, MORE_DATA, sharedCachedKeyDecoder, Decoder;
var init_Decoder = __esm({
  "node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs"() {
    init_prettyByte();
    init_ExtensionCodec();
    init_int();
    init_utf8();
    init_typedArrays();
    init_CachedKeyDecoder();
    init_DecodeError();
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    __asyncValues = function(o) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function verb(n) {
        if (g[n]) i[n] = function(v) {
          return new Promise(function(a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
      }
    };
    STATE_ARRAY = "array";
    STATE_MAP_KEY = "map_key";
    STATE_MAP_VALUE = "map_value";
    isValidMapKeyType = function(key) {
      return typeof key === "string" || typeof key === "number";
    };
    HEAD_BYTE_REQUIRED = -1;
    EMPTY_VIEW = new DataView(new ArrayBuffer(0));
    EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);
    try {
      EMPTY_VIEW.getInt8(0);
    } catch (e) {
      if (!(e instanceof RangeError)) {
        throw new Error("This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access");
      }
    }
    DataViewIndexOutOfBoundsError = RangeError;
    MORE_DATA = new DataViewIndexOutOfBoundsError("Insufficient data");
    sharedCachedKeyDecoder = new CachedKeyDecoder();
    Decoder = /** @class */
    function() {
      function Decoder2(options) {
        var _a, _b, _c, _d, _e, _f, _g;
        this.totalPos = 0;
        this.pos = 0;
        this.view = EMPTY_VIEW;
        this.bytes = EMPTY_BYTES;
        this.headByte = HEAD_BYTE_REQUIRED;
        this.stack = [];
        this.extensionCodec = (_a = options === null || options === void 0 ? void 0 : options.extensionCodec) !== null && _a !== void 0 ? _a : ExtensionCodec.defaultCodec;
        this.context = options === null || options === void 0 ? void 0 : options.context;
        this.useBigInt64 = (_b = options === null || options === void 0 ? void 0 : options.useBigInt64) !== null && _b !== void 0 ? _b : false;
        this.maxStrLength = (_c = options === null || options === void 0 ? void 0 : options.maxStrLength) !== null && _c !== void 0 ? _c : UINT32_MAX;
        this.maxBinLength = (_d = options === null || options === void 0 ? void 0 : options.maxBinLength) !== null && _d !== void 0 ? _d : UINT32_MAX;
        this.maxArrayLength = (_e = options === null || options === void 0 ? void 0 : options.maxArrayLength) !== null && _e !== void 0 ? _e : UINT32_MAX;
        this.maxMapLength = (_f = options === null || options === void 0 ? void 0 : options.maxMapLength) !== null && _f !== void 0 ? _f : UINT32_MAX;
        this.maxExtLength = (_g = options === null || options === void 0 ? void 0 : options.maxExtLength) !== null && _g !== void 0 ? _g : UINT32_MAX;
        this.keyDecoder = (options === null || options === void 0 ? void 0 : options.keyDecoder) !== void 0 ? options.keyDecoder : sharedCachedKeyDecoder;
      }
      Decoder2.prototype.reinitializeState = function() {
        this.totalPos = 0;
        this.headByte = HEAD_BYTE_REQUIRED;
        this.stack.length = 0;
      };
      Decoder2.prototype.setBuffer = function(buffer) {
        this.bytes = ensureUint8Array(buffer);
        this.view = createDataView(this.bytes);
        this.pos = 0;
      };
      Decoder2.prototype.appendBuffer = function(buffer) {
        if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {
          this.setBuffer(buffer);
        } else {
          var remainingData = this.bytes.subarray(this.pos);
          var newData = ensureUint8Array(buffer);
          var newBuffer = new Uint8Array(remainingData.length + newData.length);
          newBuffer.set(remainingData);
          newBuffer.set(newData, remainingData.length);
          this.setBuffer(newBuffer);
        }
      };
      Decoder2.prototype.hasRemaining = function(size) {
        return this.view.byteLength - this.pos >= size;
      };
      Decoder2.prototype.createExtraByteError = function(posToShow) {
        var _a = this, view = _a.view, pos = _a.pos;
        return new RangeError("Extra ".concat(view.byteLength - pos, " of ").concat(view.byteLength, " byte(s) found at buffer[").concat(posToShow, "]"));
      };
      Decoder2.prototype.decode = function(buffer) {
        this.reinitializeState();
        this.setBuffer(buffer);
        var object = this.doDecodeSync();
        if (this.hasRemaining(1)) {
          throw this.createExtraByteError(this.pos);
        }
        return object;
      };
      Decoder2.prototype.decodeMulti = function(buffer) {
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              this.reinitializeState();
              this.setBuffer(buffer);
              _a.label = 1;
            case 1:
              if (!this.hasRemaining(1)) return [3, 3];
              return [4, this.doDecodeSync()];
            case 2:
              _a.sent();
              return [3, 1];
            case 3:
              return [
                2
                /*return*/
              ];
          }
        });
      };
      Decoder2.prototype.decodeAsync = function(stream) {
        var _a, stream_1, stream_1_1;
        var _b, e_1, _c, _d;
        return __awaiter(this, void 0, void 0, function() {
          var decoded, object, buffer, e_1_1, _e, headByte, pos, totalPos;
          return __generator(this, function(_f) {
            switch (_f.label) {
              case 0:
                decoded = false;
                _f.label = 1;
              case 1:
                _f.trys.push([1, 6, 7, 12]);
                _a = true, stream_1 = __asyncValues(stream);
                _f.label = 2;
              case 2:
                return [4, stream_1.next()];
              case 3:
                if (!(stream_1_1 = _f.sent(), _b = stream_1_1.done, !_b)) return [3, 5];
                _d = stream_1_1.value;
                _a = false;
                try {
                  buffer = _d;
                  if (decoded) {
                    throw this.createExtraByteError(this.totalPos);
                  }
                  this.appendBuffer(buffer);
                  try {
                    object = this.doDecodeSync();
                    decoded = true;
                  } catch (e) {
                    if (!(e instanceof DataViewIndexOutOfBoundsError)) {
                      throw e;
                    }
                  }
                  this.totalPos += this.pos;
                } finally {
                  _a = true;
                }
                _f.label = 4;
              case 4:
                return [3, 2];
              case 5:
                return [3, 12];
              case 6:
                e_1_1 = _f.sent();
                e_1 = { error: e_1_1 };
                return [3, 12];
              case 7:
                _f.trys.push([7, , 10, 11]);
                if (!(!_a && !_b && (_c = stream_1.return))) return [3, 9];
                return [4, _c.call(stream_1)];
              case 8:
                _f.sent();
                _f.label = 9;
              case 9:
                return [3, 11];
              case 10:
                if (e_1) throw e_1.error;
                return [
                  7
                  /*endfinally*/
                ];
              case 11:
                return [
                  7
                  /*endfinally*/
                ];
              case 12:
                if (decoded) {
                  if (this.hasRemaining(1)) {
                    throw this.createExtraByteError(this.totalPos);
                  }
                  return [2, object];
                }
                _e = this, headByte = _e.headByte, pos = _e.pos, totalPos = _e.totalPos;
                throw new RangeError("Insufficient data in parsing ".concat(prettyByte(headByte), " at ").concat(totalPos, " (").concat(pos, " in the current buffer)"));
            }
          });
        });
      };
      Decoder2.prototype.decodeArrayStream = function(stream) {
        return this.decodeMultiAsync(stream, true);
      };
      Decoder2.prototype.decodeStream = function(stream) {
        return this.decodeMultiAsync(stream, false);
      };
      Decoder2.prototype.decodeMultiAsync = function(stream, isArray) {
        return __asyncGenerator(this, arguments, function decodeMultiAsync_1() {
          var isArrayHeaderRequired, arrayItemsLeft, _a, stream_2, stream_2_1, buffer, e_2, e_3_1;
          var _b, e_3, _c, _d;
          return __generator(this, function(_e) {
            switch (_e.label) {
              case 0:
                isArrayHeaderRequired = isArray;
                arrayItemsLeft = -1;
                _e.label = 1;
              case 1:
                _e.trys.push([1, 15, 16, 21]);
                _a = true, stream_2 = __asyncValues(stream);
                _e.label = 2;
              case 2:
                return [4, __await(stream_2.next())];
              case 3:
                if (!(stream_2_1 = _e.sent(), _b = stream_2_1.done, !_b)) return [3, 14];
                _d = stream_2_1.value;
                _a = false;
                _e.label = 4;
              case 4:
                _e.trys.push([4, , 12, 13]);
                buffer = _d;
                if (isArray && arrayItemsLeft === 0) {
                  throw this.createExtraByteError(this.totalPos);
                }
                this.appendBuffer(buffer);
                if (isArrayHeaderRequired) {
                  arrayItemsLeft = this.readArraySize();
                  isArrayHeaderRequired = false;
                  this.complete();
                }
                _e.label = 5;
              case 5:
                _e.trys.push([5, 10, , 11]);
                _e.label = 6;
              case 6:
                if (false) return [3, 9];
                return [4, __await(this.doDecodeSync())];
              case 7:
                return [4, _e.sent()];
              case 8:
                _e.sent();
                if (--arrayItemsLeft === 0) {
                  return [3, 9];
                }
                return [3, 6];
              case 9:
                return [3, 11];
              case 10:
                e_2 = _e.sent();
                if (!(e_2 instanceof DataViewIndexOutOfBoundsError)) {
                  throw e_2;
                }
                return [3, 11];
              case 11:
                this.totalPos += this.pos;
                return [3, 13];
              case 12:
                _a = true;
                return [
                  7
                  /*endfinally*/
                ];
              case 13:
                return [3, 2];
              case 14:
                return [3, 21];
              case 15:
                e_3_1 = _e.sent();
                e_3 = { error: e_3_1 };
                return [3, 21];
              case 16:
                _e.trys.push([16, , 19, 20]);
                if (!(!_a && !_b && (_c = stream_2.return))) return [3, 18];
                return [4, __await(_c.call(stream_2))];
              case 17:
                _e.sent();
                _e.label = 18;
              case 18:
                return [3, 20];
              case 19:
                if (e_3) throw e_3.error;
                return [
                  7
                  /*endfinally*/
                ];
              case 20:
                return [
                  7
                  /*endfinally*/
                ];
              case 21:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      Decoder2.prototype.doDecodeSync = function() {
        DECODE: while (true) {
          var headByte = this.readHeadByte();
          var object = void 0;
          if (headByte >= 224) {
            object = headByte - 256;
          } else if (headByte < 192) {
            if (headByte < 128) {
              object = headByte;
            } else if (headByte < 144) {
              var size = headByte - 128;
              if (size !== 0) {
                this.pushMapState(size);
                this.complete();
                continue DECODE;
              } else {
                object = {};
              }
            } else if (headByte < 160) {
              var size = headByte - 144;
              if (size !== 0) {
                this.pushArrayState(size);
                this.complete();
                continue DECODE;
              } else {
                object = [];
              }
            } else {
              var byteLength = headByte - 160;
              object = this.decodeUtf8String(byteLength, 0);
            }
          } else if (headByte === 192) {
            object = null;
          } else if (headByte === 194) {
            object = false;
          } else if (headByte === 195) {
            object = true;
          } else if (headByte === 202) {
            object = this.readF32();
          } else if (headByte === 203) {
            object = this.readF64();
          } else if (headByte === 204) {
            object = this.readU8();
          } else if (headByte === 205) {
            object = this.readU16();
          } else if (headByte === 206) {
            object = this.readU32();
          } else if (headByte === 207) {
            if (this.useBigInt64) {
              object = this.readU64AsBigInt();
            } else {
              object = this.readU64();
            }
          } else if (headByte === 208) {
            object = this.readI8();
          } else if (headByte === 209) {
            object = this.readI16();
          } else if (headByte === 210) {
            object = this.readI32();
          } else if (headByte === 211) {
            if (this.useBigInt64) {
              object = this.readI64AsBigInt();
            } else {
              object = this.readI64();
            }
          } else if (headByte === 217) {
            var byteLength = this.lookU8();
            object = this.decodeUtf8String(byteLength, 1);
          } else if (headByte === 218) {
            var byteLength = this.lookU16();
            object = this.decodeUtf8String(byteLength, 2);
          } else if (headByte === 219) {
            var byteLength = this.lookU32();
            object = this.decodeUtf8String(byteLength, 4);
          } else if (headByte === 220) {
            var size = this.readU16();
            if (size !== 0) {
              this.pushArrayState(size);
              this.complete();
              continue DECODE;
            } else {
              object = [];
            }
          } else if (headByte === 221) {
            var size = this.readU32();
            if (size !== 0) {
              this.pushArrayState(size);
              this.complete();
              continue DECODE;
            } else {
              object = [];
            }
          } else if (headByte === 222) {
            var size = this.readU16();
            if (size !== 0) {
              this.pushMapState(size);
              this.complete();
              continue DECODE;
            } else {
              object = {};
            }
          } else if (headByte === 223) {
            var size = this.readU32();
            if (size !== 0) {
              this.pushMapState(size);
              this.complete();
              continue DECODE;
            } else {
              object = {};
            }
          } else if (headByte === 196) {
            var size = this.lookU8();
            object = this.decodeBinary(size, 1);
          } else if (headByte === 197) {
            var size = this.lookU16();
            object = this.decodeBinary(size, 2);
          } else if (headByte === 198) {
            var size = this.lookU32();
            object = this.decodeBinary(size, 4);
          } else if (headByte === 212) {
            object = this.decodeExtension(1, 0);
          } else if (headByte === 213) {
            object = this.decodeExtension(2, 0);
          } else if (headByte === 214) {
            object = this.decodeExtension(4, 0);
          } else if (headByte === 215) {
            object = this.decodeExtension(8, 0);
          } else if (headByte === 216) {
            object = this.decodeExtension(16, 0);
          } else if (headByte === 199) {
            var size = this.lookU8();
            object = this.decodeExtension(size, 1);
          } else if (headByte === 200) {
            var size = this.lookU16();
            object = this.decodeExtension(size, 2);
          } else if (headByte === 201) {
            var size = this.lookU32();
            object = this.decodeExtension(size, 4);
          } else {
            throw new DecodeError("Unrecognized type byte: ".concat(prettyByte(headByte)));
          }
          this.complete();
          var stack = this.stack;
          while (stack.length > 0) {
            var state = stack[stack.length - 1];
            if (state.type === STATE_ARRAY) {
              state.array[state.position] = object;
              state.position++;
              if (state.position === state.size) {
                stack.pop();
                object = state.array;
              } else {
                continue DECODE;
              }
            } else if (state.type === STATE_MAP_KEY) {
              if (!isValidMapKeyType(object)) {
                throw new DecodeError("The type of key must be string or number but " + typeof object);
              }
              if (object === "__proto__") {
                throw new DecodeError("The key __proto__ is not allowed");
              }
              state.key = object;
              state.type = STATE_MAP_VALUE;
              continue DECODE;
            } else {
              state.map[state.key] = object;
              state.readCount++;
              if (state.readCount === state.size) {
                stack.pop();
                object = state.map;
              } else {
                state.key = null;
                state.type = STATE_MAP_KEY;
                continue DECODE;
              }
            }
          }
          return object;
        }
      };
      Decoder2.prototype.readHeadByte = function() {
        if (this.headByte === HEAD_BYTE_REQUIRED) {
          this.headByte = this.readU8();
        }
        return this.headByte;
      };
      Decoder2.prototype.complete = function() {
        this.headByte = HEAD_BYTE_REQUIRED;
      };
      Decoder2.prototype.readArraySize = function() {
        var headByte = this.readHeadByte();
        switch (headByte) {
          case 220:
            return this.readU16();
          case 221:
            return this.readU32();
          default: {
            if (headByte < 160) {
              return headByte - 144;
            } else {
              throw new DecodeError("Unrecognized array type byte: ".concat(prettyByte(headByte)));
            }
          }
        }
      };
      Decoder2.prototype.pushMapState = function(size) {
        if (size > this.maxMapLength) {
          throw new DecodeError("Max length exceeded: map length (".concat(size, ") > maxMapLengthLength (").concat(this.maxMapLength, ")"));
        }
        this.stack.push({
          type: STATE_MAP_KEY,
          size,
          key: null,
          readCount: 0,
          map: {}
        });
      };
      Decoder2.prototype.pushArrayState = function(size) {
        if (size > this.maxArrayLength) {
          throw new DecodeError("Max length exceeded: array length (".concat(size, ") > maxArrayLength (").concat(this.maxArrayLength, ")"));
        }
        this.stack.push({
          type: STATE_ARRAY,
          size,
          array: new Array(size),
          position: 0
        });
      };
      Decoder2.prototype.decodeUtf8String = function(byteLength, headerOffset) {
        var _a;
        if (byteLength > this.maxStrLength) {
          throw new DecodeError("Max length exceeded: UTF-8 byte length (".concat(byteLength, ") > maxStrLength (").concat(this.maxStrLength, ")"));
        }
        if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {
          throw MORE_DATA;
        }
        var offset = this.pos + headerOffset;
        var object;
        if (this.stateIsMapKey() && ((_a = this.keyDecoder) === null || _a === void 0 ? void 0 : _a.canBeCached(byteLength))) {
          object = this.keyDecoder.decode(this.bytes, offset, byteLength);
        } else {
          object = utf8Decode(this.bytes, offset, byteLength);
        }
        this.pos += headerOffset + byteLength;
        return object;
      };
      Decoder2.prototype.stateIsMapKey = function() {
        if (this.stack.length > 0) {
          var state = this.stack[this.stack.length - 1];
          return state.type === STATE_MAP_KEY;
        }
        return false;
      };
      Decoder2.prototype.decodeBinary = function(byteLength, headOffset) {
        if (byteLength > this.maxBinLength) {
          throw new DecodeError("Max length exceeded: bin length (".concat(byteLength, ") > maxBinLength (").concat(this.maxBinLength, ")"));
        }
        if (!this.hasRemaining(byteLength + headOffset)) {
          throw MORE_DATA;
        }
        var offset = this.pos + headOffset;
        var object = this.bytes.subarray(offset, offset + byteLength);
        this.pos += headOffset + byteLength;
        return object;
      };
      Decoder2.prototype.decodeExtension = function(size, headOffset) {
        if (size > this.maxExtLength) {
          throw new DecodeError("Max length exceeded: ext length (".concat(size, ") > maxExtLength (").concat(this.maxExtLength, ")"));
        }
        var extType = this.view.getInt8(this.pos + headOffset);
        var data = this.decodeBinary(
          size,
          headOffset + 1
          /* extType */
        );
        return this.extensionCodec.decode(data, extType, this.context);
      };
      Decoder2.prototype.lookU8 = function() {
        return this.view.getUint8(this.pos);
      };
      Decoder2.prototype.lookU16 = function() {
        return this.view.getUint16(this.pos);
      };
      Decoder2.prototype.lookU32 = function() {
        return this.view.getUint32(this.pos);
      };
      Decoder2.prototype.readU8 = function() {
        var value = this.view.getUint8(this.pos);
        this.pos++;
        return value;
      };
      Decoder2.prototype.readI8 = function() {
        var value = this.view.getInt8(this.pos);
        this.pos++;
        return value;
      };
      Decoder2.prototype.readU16 = function() {
        var value = this.view.getUint16(this.pos);
        this.pos += 2;
        return value;
      };
      Decoder2.prototype.readI16 = function() {
        var value = this.view.getInt16(this.pos);
        this.pos += 2;
        return value;
      };
      Decoder2.prototype.readU32 = function() {
        var value = this.view.getUint32(this.pos);
        this.pos += 4;
        return value;
      };
      Decoder2.prototype.readI32 = function() {
        var value = this.view.getInt32(this.pos);
        this.pos += 4;
        return value;
      };
      Decoder2.prototype.readU64 = function() {
        var value = getUint64(this.view, this.pos);
        this.pos += 8;
        return value;
      };
      Decoder2.prototype.readI64 = function() {
        var value = getInt64(this.view, this.pos);
        this.pos += 8;
        return value;
      };
      Decoder2.prototype.readU64AsBigInt = function() {
        var value = this.view.getBigUint64(this.pos);
        this.pos += 8;
        return value;
      };
      Decoder2.prototype.readI64AsBigInt = function() {
        var value = this.view.getBigInt64(this.pos);
        this.pos += 8;
        return value;
      };
      Decoder2.prototype.readF32 = function() {
        var value = this.view.getFloat32(this.pos);
        this.pos += 4;
        return value;
      };
      Decoder2.prototype.readF64 = function() {
        var value = this.view.getFloat64(this.pos);
        this.pos += 8;
        return value;
      };
      return Decoder2;
    }();
  }
});

// node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs
function decode(buffer, options) {
  var decoder = new Decoder(options);
  return decoder.decode(buffer);
}
function decodeMulti(buffer, options) {
  var decoder = new Decoder(options);
  return decoder.decodeMulti(buffer);
}
var init_decode = __esm({
  "node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs"() {
    init_Decoder();
  }
});

// node_modules/@msgpack/msgpack/dist.es5+esm/utils/stream.mjs
function isAsyncIterable(object) {
  return object[Symbol.asyncIterator] != null;
}
function assertNonNull(value) {
  if (value == null) {
    throw new Error("Assertion Failure: value must not be null nor undefined");
  }
}
function asyncIterableFromStream(stream) {
  return __asyncGenerator2(this, arguments, function asyncIterableFromStream_1() {
    var reader, _a, done, value;
    return __generator2(this, function(_b) {
      switch (_b.label) {
        case 0:
          reader = stream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1, , 9, 10]);
          _b.label = 2;
        case 2:
          if (false) return [3, 8];
          return [4, __await2(reader.read())];
        case 3:
          _a = _b.sent(), done = _a.done, value = _a.value;
          if (!done) return [3, 5];
          return [4, __await2(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          assertNonNull(value);
          return [4, __await2(value)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [
            7
            /*endfinally*/
          ];
        case 10:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function ensureAsyncIterable(streamLike) {
  if (isAsyncIterable(streamLike)) {
    return streamLike;
  } else {
    return asyncIterableFromStream(streamLike);
  }
}
var __generator2, __await2, __asyncGenerator2;
var init_stream = __esm({
  "node_modules/@msgpack/msgpack/dist.es5+esm/utils/stream.mjs"() {
    __generator2 = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    __await2 = function(v) {
      return this instanceof __await2 ? (this.v = v, this) : new __await2(v);
    };
    __asyncGenerator2 = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function verb(n) {
        if (g[n]) i[n] = function(v) {
          return new Promise(function(a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await2 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
      }
    };
  }
});

// node_modules/@msgpack/msgpack/dist.es5+esm/decodeAsync.mjs
function decodeAsync(streamLike, options) {
  return __awaiter2(this, void 0, void 0, function() {
    var stream, decoder;
    return __generator3(this, function(_a) {
      stream = ensureAsyncIterable(streamLike);
      decoder = new Decoder(options);
      return [2, decoder.decodeAsync(stream)];
    });
  });
}
function decodeArrayStream(streamLike, options) {
  var stream = ensureAsyncIterable(streamLike);
  var decoder = new Decoder(options);
  return decoder.decodeArrayStream(stream);
}
function decodeMultiStream(streamLike, options) {
  var stream = ensureAsyncIterable(streamLike);
  var decoder = new Decoder(options);
  return decoder.decodeStream(stream);
}
var __awaiter2, __generator3, decodeStream;
var init_decodeAsync = __esm({
  "node_modules/@msgpack/msgpack/dist.es5+esm/decodeAsync.mjs"() {
    init_Decoder();
    init_stream();
    __awaiter2 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator3 = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    decodeStream = void 0;
  }
});

// node_modules/@msgpack/msgpack/dist.es5+esm/index.mjs
var dist_exports = {};
__export(dist_exports, {
  DataViewIndexOutOfBoundsError: () => DataViewIndexOutOfBoundsError,
  DecodeError: () => DecodeError,
  Decoder: () => Decoder,
  EXT_TIMESTAMP: () => EXT_TIMESTAMP,
  Encoder: () => Encoder,
  ExtData: () => ExtData,
  ExtensionCodec: () => ExtensionCodec,
  decode: () => decode,
  decodeArrayStream: () => decodeArrayStream,
  decodeAsync: () => decodeAsync,
  decodeMulti: () => decodeMulti,
  decodeMultiStream: () => decodeMultiStream,
  decodeStream: () => decodeStream,
  decodeTimestampExtension: () => decodeTimestampExtension,
  decodeTimestampToTimeSpec: () => decodeTimestampToTimeSpec,
  encode: () => encode,
  encodeDateToTimeSpec: () => encodeDateToTimeSpec,
  encodeTimeSpecToTimestamp: () => encodeTimeSpecToTimestamp,
  encodeTimestampExtension: () => encodeTimestampExtension
});
var init_dist = __esm({
  "node_modules/@msgpack/msgpack/dist.es5+esm/index.mjs"() {
    init_encode();
    init_decode();
    init_decodeAsync();
    init_Decoder();
    init_DecodeError();
    init_Encoder();
    init_ExtensionCodec();
    init_ExtData();
    init_timestamp();
  }
});

// node_modules/robot3/dist/machine.js
var require_machine = __commonJS({
  "node_modules/robot3/dist/machine.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function valueEnumerable(value) {
      return { enumerable: true, value };
    }
    function valueEnumerableWritable(value) {
      return { enumerable: true, writable: true, value };
    }
    var d = {};
    var truthy = () => true;
    var empty = () => ({});
    var identity = (a) => a;
    var callBoth = (par, fn, self, args) => par.apply(self, args) && fn.apply(self, args);
    var callForward = (par, fn, self, [a, b]) => fn.call(self, par.call(self, a, b), b);
    var create = (a, b) => Object.freeze(Object.create(a, b));
    function stack(fns, def, caller) {
      return fns.reduce((par, fn) => {
        return function(...args) {
          return caller(par, fn, this, args);
        };
      }, def);
    }
    function fnType(fn) {
      return create(this, { fn: valueEnumerable(fn) });
    }
    var reduceType = {};
    var reduce = fnType.bind(reduceType);
    var action = (fn) => reduce((ctx, ev) => !!~fn(ctx, ev) && ctx);
    var guardType = {};
    var guard = fnType.bind(guardType);
    function filter(Type, arr) {
      return arr.filter((value) => Type.isPrototypeOf(value));
    }
    function makeTransition(from, to, ...args) {
      let guards = stack(filter(guardType, args).map((t) => t.fn), truthy, callBoth);
      let reducers = stack(filter(reduceType, args).map((t) => t.fn), identity, callForward);
      return create(this, {
        from: valueEnumerable(from),
        to: valueEnumerable(to),
        guards: valueEnumerable(guards),
        reducers: valueEnumerable(reducers)
      });
    }
    var transitionType = {};
    var immediateType = {};
    var transition = makeTransition.bind(transitionType);
    var immediate = makeTransition.bind(immediateType, null);
    function enterImmediate(machine2, service2, event) {
      return transitionTo(service2, machine2, event, this.immediates) || machine2;
    }
    function transitionsToMap(transitions) {
      let m = /* @__PURE__ */ new Map();
      for (let t of transitions) {
        if (!m.has(t.from)) m.set(t.from, []);
        m.get(t.from).push(t);
      }
      return m;
    }
    var stateType = { enter: identity };
    function state(...args) {
      let transitions = filter(transitionType, args);
      let immediates = filter(immediateType, args);
      let desc = {
        final: valueEnumerable(args.length === 0),
        transitions: valueEnumerable(transitionsToMap(transitions))
      };
      if (immediates.length) {
        desc.immediates = valueEnumerable(immediates);
        desc.enter = valueEnumerable(enterImmediate);
      }
      return create(stateType, desc);
    }
    var invokeFnType = {
      enter(machine2, service2, event) {
        let rn = this.fn.call(service2, service2.context, event);
        if (machine.isPrototypeOf(rn))
          return create(invokeMachineType, {
            machine: valueEnumerable(rn),
            transitions: valueEnumerable(this.transitions)
          }).enter(machine2, service2, event);
        rn.then((data) => service2.send({ type: "done", data })).catch((error) => service2.send({ type: "error", error }));
        return machine2;
      }
    };
    var invokeMachineType = {
      enter(machine2, service2, event) {
        service2.child = interpret(this.machine, (s) => {
          service2.onChange(s);
          if (service2.child == s && s.machine.state.value.final) {
            delete service2.child;
            service2.send({ type: "done", data: s.context });
          }
        }, service2.context, event);
        if (service2.child.machine.state.value.final) {
          let data = service2.child.context;
          delete service2.child;
          return transitionTo(service2, machine2, { type: "done", data }, this.transitions.get("done"));
        }
        return machine2;
      }
    };
    function invoke(fn, ...transitions) {
      let t = valueEnumerable(transitionsToMap(transitions));
      return machine.isPrototypeOf(fn) ? create(invokeMachineType, {
        machine: valueEnumerable(fn),
        transitions: t
      }) : create(invokeFnType, {
        fn: valueEnumerable(fn),
        transitions: t
      });
    }
    var machine = {
      get state() {
        return {
          name: this.current,
          value: this.states[this.current]
        };
      }
    };
    function createMachine(current, states, contextFn = empty) {
      if (typeof current !== "string") {
        contextFn = states || empty;
        states = current;
        current = Object.keys(states)[0];
      }
      if (d._create) d._create(current, states);
      return create(machine, {
        context: valueEnumerable(contextFn),
        current: valueEnumerable(current),
        states: valueEnumerable(states)
      });
    }
    function transitionTo(service2, machine2, fromEvent, candidates) {
      let { context } = service2;
      for (let { to, guards, reducers } of candidates) {
        if (guards(context, fromEvent)) {
          service2.context = reducers.call(service2, context, fromEvent);
          let original = machine2.original || machine2;
          let newMachine = create(original, {
            current: valueEnumerable(to),
            original: { value: original }
          });
          if (d._onEnter) d._onEnter(machine2, to, service2.context, context, fromEvent);
          let state2 = newMachine.state.value;
          return state2.enter(newMachine, service2, fromEvent);
        }
      }
    }
    function send(service2, event) {
      let eventName = event.type || event;
      let { machine: machine2 } = service2;
      let { value: state2, name: currentStateName } = machine2.state;
      if (state2.transitions.has(eventName)) {
        return transitionTo(service2, machine2, event, state2.transitions.get(eventName)) || machine2;
      } else {
        if (d._send) d._send(eventName, currentStateName);
      }
      return machine2;
    }
    var service = {
      send(event) {
        this.machine = send(this, event);
        this.onChange(this);
      }
    };
    function interpret(machine2, onChange, initialContext, event) {
      let s = Object.create(service, {
        machine: valueEnumerableWritable(machine2),
        context: valueEnumerableWritable(machine2.context(initialContext, event)),
        onChange: valueEnumerable(onChange)
      });
      s.send = s.send.bind(s);
      s.machine = s.machine.state.value.enter(s.machine, s, event);
      return s;
    }
    exports.action = action;
    exports.createMachine = createMachine;
    exports.d = d;
    exports.guard = guard;
    exports.immediate = immediate;
    exports.interpret = interpret;
    exports.invoke = invoke;
    exports.reduce = reduce;
    exports.state = state;
    exports.transition = transition;
  }
});

// node_modules/@fal-ai/serverless-client/src/realtime.js
var require_realtime = __commonJS({
  "node_modules/@fal-ai/serverless-client/src/realtime.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.realtimeImpl = void 0;
    var msgpack_1 = (init_dist(), __toCommonJS(dist_exports));
    var robot3_1 = require_machine();
    var auth_1 = require_auth();
    var response_1 = require_response();
    var runtime_1 = require_runtime();
    var utils_1 = require_utils();
    var initialState = () => ({
      enqueuedMessage: void 0
    });
    function hasToken(context) {
      return context.token !== void 0;
    }
    function noToken(context) {
      return !hasToken(context);
    }
    function enqueueMessage(context, event) {
      return Object.assign(Object.assign({}, context), { enqueuedMessage: event.message });
    }
    function closeConnection(context) {
      if (context.websocket && context.websocket.readyState === WebSocket.OPEN) {
        context.websocket.close();
      }
      return Object.assign(Object.assign({}, context), { websocket: void 0 });
    }
    function sendMessage(context, event) {
      if (context.websocket && context.websocket.readyState === WebSocket.OPEN) {
        if (event.message instanceof Uint8Array) {
          context.websocket.send(event.message);
        } else {
          context.websocket.send((0, msgpack_1.encode)(event.message));
        }
        return Object.assign(Object.assign({}, context), { enqueuedMessage: void 0 });
      }
      return Object.assign(Object.assign({}, context), { enqueuedMessage: event.message });
    }
    function expireToken(context) {
      return Object.assign(Object.assign({}, context), { token: void 0 });
    }
    function setToken(context, event) {
      return Object.assign(Object.assign({}, context), { token: event.token });
    }
    function connectionEstablished(context, event) {
      return Object.assign(Object.assign({}, context), { websocket: event.websocket });
    }
    var connectionStateMachine = (0, robot3_1.createMachine)("idle", {
      idle: (0, robot3_1.state)((0, robot3_1.transition)("send", "connecting", (0, robot3_1.reduce)(enqueueMessage)), (0, robot3_1.transition)("expireToken", "idle", (0, robot3_1.reduce)(expireToken)), (0, robot3_1.transition)("close", "idle", (0, robot3_1.reduce)(closeConnection))),
      connecting: (0, robot3_1.state)((0, robot3_1.transition)("connecting", "connecting"), (0, robot3_1.transition)("connected", "active", (0, robot3_1.reduce)(connectionEstablished)), (0, robot3_1.transition)("connectionClosed", "idle", (0, robot3_1.reduce)(closeConnection)), (0, robot3_1.transition)("send", "connecting", (0, robot3_1.reduce)(enqueueMessage)), (0, robot3_1.transition)("close", "idle", (0, robot3_1.reduce)(closeConnection)), (0, robot3_1.immediate)("authRequired", (0, robot3_1.guard)(noToken))),
      authRequired: (0, robot3_1.state)((0, robot3_1.transition)("initiateAuth", "authInProgress"), (0, robot3_1.transition)("send", "authRequired", (0, robot3_1.reduce)(enqueueMessage)), (0, robot3_1.transition)("close", "idle", (0, robot3_1.reduce)(closeConnection))),
      authInProgress: (0, robot3_1.state)((0, robot3_1.transition)("authenticated", "connecting", (0, robot3_1.reduce)(setToken)), (0, robot3_1.transition)("unauthorized", "idle", (0, robot3_1.reduce)(expireToken), (0, robot3_1.reduce)(closeConnection)), (0, robot3_1.transition)("send", "authInProgress", (0, robot3_1.reduce)(enqueueMessage)), (0, robot3_1.transition)("close", "idle", (0, robot3_1.reduce)(closeConnection))),
      active: (0, robot3_1.state)((0, robot3_1.transition)("send", "active", (0, robot3_1.reduce)(sendMessage)), (0, robot3_1.transition)("unauthorized", "idle", (0, robot3_1.reduce)(expireToken)), (0, robot3_1.transition)("connectionClosed", "idle", (0, robot3_1.reduce)(closeConnection)), (0, robot3_1.transition)("close", "idle", (0, robot3_1.reduce)(closeConnection))),
      failed: (0, robot3_1.state)((0, robot3_1.transition)("send", "failed"), (0, robot3_1.transition)("close", "idle", (0, robot3_1.reduce)(closeConnection)))
    }, initialState);
    function buildRealtimeUrl(app, { token, maxBuffering }) {
      if (maxBuffering !== void 0 && (maxBuffering < 1 || maxBuffering > 60)) {
        throw new Error("The `maxBuffering` must be between 1 and 60 (inclusive)");
      }
      const queryParams = new URLSearchParams({
        fal_jwt_token: token
      });
      if (maxBuffering !== void 0) {
        queryParams.set("max_buffering", maxBuffering.toFixed(0));
      }
      const appId = (0, utils_1.ensureAppIdFormat)(app);
      return `wss://fal.run/${appId}/realtime?${queryParams.toString()}`;
    }
    var DEFAULT_THROTTLE_INTERVAL = 128;
    function isUnauthorizedError(message) {
      return message["status"] === "error" && message["error"] === "Unauthorized";
    }
    var WebSocketErrorCodes = {
      NORMAL_CLOSURE: 1e3,
      GOING_AWAY: 1001
    };
    var connectionCache = /* @__PURE__ */ new Map();
    var connectionCallbacks = /* @__PURE__ */ new Map();
    function reuseInterpreter(key, throttleInterval, onChange) {
      if (!connectionCache.has(key)) {
        const machine = (0, robot3_1.interpret)(connectionStateMachine, onChange);
        connectionCache.set(key, Object.assign(Object.assign({}, machine), { throttledSend: throttleInterval > 0 ? (0, utils_1.throttle)(machine.send, throttleInterval, true) : machine.send }));
      }
      return connectionCache.get(key);
    }
    var noop = () => {
    };
    var NoOpConnection = {
      send: noop,
      close: noop
    };
    function isSuccessfulResult(data) {
      return data.status !== "error" && data.type !== "x-fal-message" && !isFalErrorResult(data);
    }
    function isFalErrorResult(data) {
      return data.type === "x-fal-error";
    }
    exports.realtimeImpl = {
      connect(app, handler) {
        const {
          // if running on React in the server, set clientOnly to true by default
          clientOnly = (0, utils_1.isReact)() && !(0, runtime_1.isBrowser)(),
          connectionKey = crypto.randomUUID(),
          maxBuffering,
          throttleInterval = DEFAULT_THROTTLE_INTERVAL
        } = handler;
        if (clientOnly && !(0, runtime_1.isBrowser)()) {
          return NoOpConnection;
        }
        let previousState;
        connectionCallbacks.set(connectionKey, {
          onError: handler.onError,
          onResult: handler.onResult
        });
        const getCallbacks = () => connectionCallbacks.get(connectionKey);
        const stateMachine = reuseInterpreter(connectionKey, throttleInterval, ({ context, machine, send: send2 }) => {
          const { enqueuedMessage, token } = context;
          if (machine.current === "active" && enqueuedMessage) {
            send2({ type: "send", message: enqueuedMessage });
          }
          if (machine.current === "authRequired" && token === void 0 && previousState !== machine.current) {
            send2({ type: "initiateAuth" });
            (0, auth_1.getTemporaryAuthToken)(app).then((token2) => {
              send2({ type: "authenticated", token: token2 });
              const tokenExpirationTimeout = Math.round(auth_1.TOKEN_EXPIRATION_SECONDS * 0.9 * 1e3);
              setTimeout(() => {
                send2({ type: "expireToken" });
              }, tokenExpirationTimeout);
            }).catch((error) => {
              send2({ type: "unauthorized", error });
            });
          }
          if (machine.current === "connecting" && previousState !== machine.current && token !== void 0) {
            const ws = new WebSocket(buildRealtimeUrl(app, { token, maxBuffering }));
            ws.onopen = () => {
              send2({ type: "connected", websocket: ws });
            };
            ws.onclose = (event) => {
              if (event.code !== WebSocketErrorCodes.NORMAL_CLOSURE) {
                const { onError = noop } = getCallbacks();
                onError(new response_1.ApiError({
                  message: `Error closing the connection: ${event.reason}`,
                  status: event.code
                }));
              }
              send2({ type: "connectionClosed", code: event.code });
            };
            ws.onerror = (event) => {
              const { onError = noop } = getCallbacks();
              onError(new response_1.ApiError({ message: "Unknown error", status: 500 }));
            };
            ws.onmessage = (event) => {
              const { onResult } = getCallbacks();
              if (event.data instanceof ArrayBuffer) {
                const result = (0, msgpack_1.decode)(new Uint8Array(event.data));
                onResult(result);
                return;
              }
              if (event.data instanceof Uint8Array) {
                const result = (0, msgpack_1.decode)(event.data);
                onResult(result);
                return;
              }
              if (event.data instanceof Blob) {
                event.data.arrayBuffer().then((buffer) => {
                  const result = (0, msgpack_1.decode)(new Uint8Array(buffer));
                  onResult(result);
                });
                return;
              }
              const data = JSON.parse(event.data);
              if (isUnauthorizedError(data)) {
                send2({ type: "unauthorized", error: new Error("Unauthorized") });
                return;
              }
              if (isSuccessfulResult(data)) {
                onResult(data);
                return;
              }
              if (isFalErrorResult(data)) {
                if (data.error === "TIMEOUT") {
                  return;
                }
                const { onError = noop } = getCallbacks();
                onError(new response_1.ApiError({
                  message: `${data.error}: ${data.reason}`,
                  // TODO better error status code
                  status: 400,
                  body: data
                }));
                return;
              }
            };
          }
          previousState = machine.current;
        });
        const send = (input) => {
          var _a;
          const message = input instanceof Uint8Array ? input : Object.assign(Object.assign({}, input), { request_id: (_a = input["request_id"]) !== null && _a !== void 0 ? _a : crypto.randomUUID() });
          stateMachine.throttledSend({
            type: "send",
            message
          });
        };
        const close = () => {
          stateMachine.send({ type: "close" });
        };
        return {
          send,
          close
        };
      }
    };
  }
});

// node_modules/@fal-ai/serverless-client/src/index.js
var require_src = __commonJS({
  "node_modules/@fal-ai/serverless-client/src/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseAppId = exports.stream = exports.storage = exports.ValidationError = exports.ApiError = exports.realtime = exports.withProxy = exports.withMiddleware = exports.subscribe = exports.run = exports.queue = exports.getConfig = exports.config = void 0;
    var config_1 = require_config();
    Object.defineProperty(exports, "config", { enumerable: true, get: function() {
      return config_1.config;
    } });
    Object.defineProperty(exports, "getConfig", { enumerable: true, get: function() {
      return config_1.getConfig;
    } });
    var function_1 = require_function();
    Object.defineProperty(exports, "queue", { enumerable: true, get: function() {
      return function_1.queue;
    } });
    Object.defineProperty(exports, "run", { enumerable: true, get: function() {
      return function_1.run;
    } });
    Object.defineProperty(exports, "subscribe", { enumerable: true, get: function() {
      return function_1.subscribe;
    } });
    var middleware_1 = require_middleware();
    Object.defineProperty(exports, "withMiddleware", { enumerable: true, get: function() {
      return middleware_1.withMiddleware;
    } });
    Object.defineProperty(exports, "withProxy", { enumerable: true, get: function() {
      return middleware_1.withProxy;
    } });
    var realtime_1 = require_realtime();
    Object.defineProperty(exports, "realtime", { enumerable: true, get: function() {
      return realtime_1.realtimeImpl;
    } });
    var response_1 = require_response();
    Object.defineProperty(exports, "ApiError", { enumerable: true, get: function() {
      return response_1.ApiError;
    } });
    Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function() {
      return response_1.ValidationError;
    } });
    var storage_1 = require_storage();
    Object.defineProperty(exports, "storage", { enumerable: true, get: function() {
      return storage_1.storageImpl;
    } });
    var streaming_1 = require_streaming();
    Object.defineProperty(exports, "stream", { enumerable: true, get: function() {
      return streaming_1.stream;
    } });
    var utils_1 = require_utils();
    Object.defineProperty(exports, "parseAppId", { enumerable: true, get: function() {
      return utils_1.parseAppId;
    } });
  }
});
export default require_src();
//# sourceMappingURL=@fal-ai_serverless-client.js.map
