{
  "version": 3,
  "sources": ["../../../libs/client/src/middleware.ts", "../../../libs/client/src/response.ts", "../../../libs/client/src/config.ts", "../../@fal-ai/serverless-client/package.json", "../../../libs/client/src/runtime.ts", "../../../libs/client/src/request.ts", "../../../libs/client/src/utils.ts", "../../../libs/client/src/storage.ts", "../../eventsource-parser/src/parse.ts", "../../../libs/client/src/auth.ts", "../../../libs/client/src/streaming.ts", "../../../libs/client/src/function.ts", "../../@msgpack/msgpack/src/utils/utf8.ts", "../../@msgpack/msgpack/src/ExtData.ts", "../../@msgpack/msgpack/src/DecodeError.ts", "../../@msgpack/msgpack/src/utils/int.ts", "../../@msgpack/msgpack/src/timestamp.ts", "../../@msgpack/msgpack/src/ExtensionCodec.ts", "../../@msgpack/msgpack/src/utils/typedArrays.ts", "../../@msgpack/msgpack/src/Encoder.ts", "../../@msgpack/msgpack/src/encode.ts", "../../@msgpack/msgpack/src/utils/prettyByte.ts", "../../@msgpack/msgpack/src/CachedKeyDecoder.ts", "../../@msgpack/msgpack/src/Decoder.ts", "../../@msgpack/msgpack/src/decode.ts", "../../@msgpack/msgpack/src/utils/stream.ts", "../../@msgpack/msgpack/src/decodeAsync.ts", "../../@msgpack/msgpack/src/index.ts", "../../robot3/dist/machine.js", "../../../libs/client/src/realtime.ts", "../../../libs/client/src/index.ts"],
  "sourcesContent": ["/**\n * A request configuration object.\n *\n * **Note:** This is a simplified version of the `RequestConfig` type from the\n * `fetch` API. It contains only the properties that are relevant for the\n * fal client. It also works around the fact that the `fetch` API `Request`\n * does not support mutability, its clone method has critical limitations\n * to our use case.\n */\nexport type RequestConfig = {\n  url: string;\n  method: string;\n  headers?: Record<string, string | string[]>;\n};\n\nexport type RequestMiddleware = (\n  request: RequestConfig,\n) => Promise<RequestConfig>;\n\n/**\n * Setup a execution chain of middleware functions.\n *\n * @param middlewares one or more middleware functions.\n * @returns a middleware function that executes the given middlewares in order.\n */\nexport function withMiddleware(\n  ...middlewares: RequestMiddleware[]\n): RequestMiddleware {\n  return (config) =>\n    middlewares.reduce(\n      (configPromise, middleware) =>\n        configPromise.then((req) => middleware(req)),\n      Promise.resolve(config),\n    );\n}\n\nexport type RequestProxyConfig = {\n  targetUrl: string;\n};\n\nexport const TARGET_URL_HEADER = \"x-fal-target-url\";\n\nexport function withProxy(config: RequestProxyConfig): RequestMiddleware {\n  // when running on the server, we don't need to proxy the request\n  if (typeof window === \"undefined\") {\n    return (requestConfig) => Promise.resolve(requestConfig);\n  }\n  return (requestConfig) =>\n    Promise.resolve({\n      ...requestConfig,\n      url: config.targetUrl,\n      headers: {\n        ...(requestConfig.headers || {}),\n        [TARGET_URL_HEADER]: requestConfig.url,\n      },\n    });\n}\n", "import { ValidationErrorInfo } from \"./types\";\n\nexport type ResponseHandler<Output> = (response: Response) => Promise<Output>;\n\ntype ApiErrorArgs = {\n  message: string;\n  status: number;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  body?: any;\n};\n\nexport class ApiError<Body> extends Error {\n  public readonly status: number;\n  public readonly body: Body;\n  constructor({ message, status, body }: ApiErrorArgs) {\n    super(message);\n    this.name = \"ApiError\";\n    this.status = status;\n    this.body = body;\n  }\n}\n\ntype ValidationErrorBody = {\n  detail: ValidationErrorInfo[];\n};\n\nexport class ValidationError extends ApiError<ValidationErrorBody> {\n  constructor(args: ApiErrorArgs) {\n    super(args);\n    this.name = \"ValidationError\";\n  }\n\n  get fieldErrors(): ValidationErrorInfo[] {\n    // NOTE: this is a hack to support both FastAPI/Pydantic errors\n    // and some custom 422 errors that might not be in the Pydantic format.\n    if (typeof this.body.detail === \"string\") {\n      return [\n        {\n          loc: [\"body\"],\n          msg: this.body.detail,\n          type: \"value_error\",\n        },\n      ];\n    }\n    return this.body.detail || [];\n  }\n\n  getFieldErrors(field: string): ValidationErrorInfo[] {\n    return this.fieldErrors.filter(\n      (error) => error.loc[error.loc.length - 1] === field,\n    );\n  }\n}\n\nexport async function defaultResponseHandler<Output>(\n  response: Response,\n): Promise<Output> {\n  const { status, statusText } = response;\n  const contentType = response.headers.get(\"Content-Type\") ?? \"\";\n  if (!response.ok) {\n    if (contentType.includes(\"application/json\")) {\n      const body = await response.json();\n      const ErrorType = status === 422 ? ValidationError : ApiError;\n      throw new ErrorType({\n        message: body.message || statusText,\n        status,\n        body,\n      });\n    }\n    throw new ApiError({ message: `HTTP ${status}: ${statusText}`, status });\n  }\n  if (contentType.includes(\"application/json\")) {\n    return response.json() as Promise<Output>;\n  }\n  if (contentType.includes(\"text/html\")) {\n    return response.text() as Promise<Output>;\n  }\n  if (contentType.includes(\"application/octet-stream\")) {\n    return response.arrayBuffer() as Promise<Output>;\n  }\n  // TODO convert to either number or bool automatically\n  return response.text() as Promise<Output>;\n}\n", "import {\n  withMiddleware,\n  withProxy,\n  type RequestMiddleware,\n} from \"./middleware\";\nimport type { ResponseHandler } from \"./response\";\nimport { defaultResponseHandler } from \"./response\";\n\nexport type CredentialsResolver = () => string | undefined;\n\ntype FetchType = typeof fetch;\n\nexport function resolveDefaultFetch(): FetchType {\n  if (typeof fetch === \"undefined\") {\n    throw new Error(\n      \"Your environment does not support fetch. Please provide your own fetch implementation.\",\n    );\n  }\n  return fetch;\n}\n\nexport type Config = {\n  /**\n   * The credentials to use for the fal serverless client. When using the\n   * client in the browser, it's recommended to use a proxy server to avoid\n   * exposing the credentials in the client's environment.\n   *\n   * By default it tries to use the `FAL_KEY` environment variable, when\n   * `process.env` is defined.\n   *\n   * @see https://fal.ai/docs/model-endpoints/server-side\n   * @see #suppressLocalCredentialsWarning\n   */\n  credentials?: undefined | string | CredentialsResolver;\n  /**\n   * Suppresses the warning when the fal credentials are exposed in the\n   * browser's environment. Make sure you understand the security implications\n   * before enabling this option.\n   */\n  suppressLocalCredentialsWarning?: boolean;\n  /**\n   * The URL of the proxy server to use for the client requests. The proxy\n   * server should forward the requests to the fal serverless rest api.\n   */\n  proxyUrl?: string;\n  /**\n   * The request middleware to use for the client requests. By default it\n   * doesn't apply any middleware.\n   */\n  requestMiddleware?: RequestMiddleware;\n  /**\n   * The response handler to use for the client requests. By default it uses\n   * a built-in response handler that returns the JSON response.\n   */\n  responseHandler?: ResponseHandler<any>;\n  /**\n   * The fetch implementation to use for the client requests. By default it uses\n   * the global `fetch` function.\n   */\n  fetch?: FetchType;\n};\n\nexport type RequiredConfig = Required<Config>;\n\n/**\n * Checks if the required FAL environment variables are set.\n *\n * @returns `true` if the required environment variables are set,\n * `false` otherwise.\n */\nfunction hasEnvVariables(): boolean {\n  return (\n    typeof process !== \"undefined\" &&\n    process.env &&\n    (typeof process.env.FAL_KEY !== \"undefined\" ||\n      (typeof process.env.FAL_KEY_ID !== \"undefined\" &&\n        typeof process.env.FAL_KEY_SECRET !== \"undefined\"))\n  );\n}\n\nexport const credentialsFromEnv: CredentialsResolver = () => {\n  if (!hasEnvVariables()) {\n    return undefined;\n  }\n\n  if (typeof process.env.FAL_KEY !== \"undefined\") {\n    return process.env.FAL_KEY;\n  }\n\n  return `${process.env.FAL_KEY_ID}:${process.env.FAL_KEY_SECRET}`;\n};\n\nconst DEFAULT_CONFIG: Partial<Config> = {\n  credentials: credentialsFromEnv,\n  suppressLocalCredentialsWarning: false,\n  requestMiddleware: (request) => Promise.resolve(request),\n  responseHandler: defaultResponseHandler,\n};\n\nlet configuration: RequiredConfig;\n\n/**\n * Configures the fal serverless client.\n *\n * @param config the new configuration.\n */\nexport function config(config: Config) {\n  configuration = {\n    ...DEFAULT_CONFIG,\n    ...config,\n    fetch: config.fetch ?? resolveDefaultFetch(),\n  } as RequiredConfig;\n  if (config.proxyUrl) {\n    configuration = {\n      ...configuration,\n      requestMiddleware: withMiddleware(\n        withProxy({ targetUrl: config.proxyUrl }),\n        configuration.requestMiddleware,\n      ),\n    };\n  }\n  const { credentials: resolveCredentials, suppressLocalCredentialsWarning } =\n    configuration;\n  const credentials =\n    typeof resolveCredentials === \"function\"\n      ? resolveCredentials()\n      : resolveCredentials;\n  if (\n    typeof window !== \"undefined\" &&\n    credentials &&\n    !suppressLocalCredentialsWarning\n  ) {\n    console.warn(\n      \"The fal credentials are exposed in the browser's environment. \" +\n        \"That's not recommended for production use cases.\",\n    );\n  }\n}\n\n/**\n * Get the current fal serverless client configuration.\n *\n * @returns the current client configuration.\n */\nexport function getConfig(): RequiredConfig {\n  if (!configuration) {\n    console.info(\"Using default configuration for the fal client\");\n    return {\n      ...DEFAULT_CONFIG,\n      fetch: resolveDefaultFetch(),\n    } as RequiredConfig;\n  }\n  return configuration;\n}\n\n/**\n * @returns the URL of the fal serverless rest api endpoint.\n */\nexport function getRestApiUrl(): string {\n  return \"https://rest.alpha.fal.ai\";\n}\n", "{\n  \"name\": \"@fal-ai/serverless-client\",\n  \"description\": \"Deprecation note: this library has been deprecated in favor of @fal-ai/client\",\n  \"version\": \"0.15.0\",\n  \"license\": \"MIT\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/fal-ai/fal-js.git\",\n    \"directory\": \"libs/client\"\n  },\n  \"keywords\": [\n    \"fal\",\n    \"serverless\",\n    \"client\",\n    \"ai\",\n    \"ml\"\n  ],\n  \"dependencies\": {\n    \"@msgpack/msgpack\": \"^3.0.0-beta2\",\n    \"eventsource-parser\": \"^1.1.2\",\n    \"robot3\": \"^0.4.1\"\n  },\n  \"engines\": {\n    \"node\": \">=18.0.0\"\n  },\n  \"main\": \"./src/index.js\",\n  \"type\": \"commonjs\"\n}\n", "/* eslint-disable @typescript-eslint/no-var-requires */\n\nexport function isBrowser(): boolean {\n  return (\n    typeof window !== \"undefined\" && typeof window.document !== \"undefined\"\n  );\n}\n\nlet memoizedUserAgent: string | null = null;\n\nexport function getUserAgent(): string {\n  if (memoizedUserAgent !== null) {\n    return memoizedUserAgent;\n  }\n  const packageInfo = require(\"../package.json\");\n  memoizedUserAgent = `${packageInfo.name}/${packageInfo.version}`;\n  return memoizedUserAgent;\n}\n", "import { getConfig } from \"./config\";\nimport { ResponseHandler } from \"./response\";\nimport { getUserAgent, isBrowser } from \"./runtime\";\n\nconst isCloudflareWorkers =\n  typeof navigator !== \"undefined\" &&\n  navigator?.userAgent === \"Cloudflare-Workers\";\n\ntype RequestOptions = {\n  responseHandler?: ResponseHandler<any>;\n};\n\nexport async function dispatchRequest<Input, Output>(\n  method: string,\n  targetUrl: string,\n  input: Input,\n  options: RequestOptions & RequestInit = {},\n): Promise<Output> {\n  const {\n    credentials: credentialsValue,\n    requestMiddleware,\n    responseHandler,\n    fetch,\n  } = getConfig();\n  const userAgent = isBrowser() ? {} : { \"User-Agent\": getUserAgent() };\n  const credentials =\n    typeof credentialsValue === \"function\"\n      ? credentialsValue()\n      : credentialsValue;\n\n  const { url, headers } = await requestMiddleware({\n    url: targetUrl,\n    method: method.toUpperCase(),\n  });\n  const authHeader = credentials ? { Authorization: `Key ${credentials}` } : {};\n  const requestHeaders = {\n    ...authHeader,\n    Accept: \"application/json\",\n    \"Content-Type\": \"application/json\",\n    ...userAgent,\n    ...(headers ?? {}),\n  } as HeadersInit;\n\n  const { responseHandler: customResponseHandler, ...requestInit } = options;\n  const response = await fetch(url, {\n    ...requestInit,\n    method,\n    headers: {\n      ...requestHeaders,\n      ...(requestInit.headers ?? {}),\n    },\n    ...(!isCloudflareWorkers && { mode: \"cors\" }),\n    body:\n      method.toLowerCase() !== \"get\" && input\n        ? JSON.stringify(input)\n        : undefined,\n  });\n  const handleResponse = customResponseHandler ?? responseHandler;\n  return await handleResponse(response);\n}\n", "export function ensureAppIdFormat(id: string): string {\n  const parts = id.split(\"/\");\n  if (parts.length > 1) {\n    return id;\n  }\n  const [, appOwner, appId] = /^([0-9]+)-([a-zA-Z0-9-]+)$/.exec(id) || [];\n  if (appOwner && appId) {\n    return `${appOwner}/${appId}`;\n  }\n  throw new Error(\n    `Invalid app id: ${id}. Must be in the format <appOwner>/<appId>`,\n  );\n}\n\nconst APP_NAMESPACES = [\"workflows\", \"comfy\"] as const;\n\ntype AppNamespace = (typeof APP_NAMESPACES)[number];\n\nexport type AppId = {\n  readonly owner: string;\n  readonly alias: string;\n  readonly path?: string;\n  readonly namespace?: AppNamespace;\n};\n\nexport function parseAppId(id: string): AppId {\n  const normalizedId = ensureAppIdFormat(id);\n  const parts = normalizedId.split(\"/\");\n  if (APP_NAMESPACES.includes(parts[0] as any)) {\n    return {\n      owner: parts[1],\n      alias: parts[2],\n      path: parts.slice(3).join(\"/\") || undefined,\n      namespace: parts[0] as AppNamespace,\n    };\n  }\n  return {\n    owner: parts[0],\n    alias: parts[1],\n    path: parts.slice(2).join(\"/\") || undefined,\n  };\n}\n\nexport function isValidUrl(url: string) {\n  try {\n    const { host } = new URL(url);\n    return /(fal\\.(ai|run))$/.test(host);\n  } catch (_) {\n    return false;\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function throttle<T extends (...args: any[]) => any>(\n  func: T,\n  limit: number,\n  leading = false,\n): (...funcArgs: Parameters<T>) => ReturnType<T> | void {\n  let lastFunc: NodeJS.Timeout | null;\n  let lastRan: number;\n\n  return (...args: Parameters<T>): ReturnType<T> | void => {\n    if (!lastRan && leading) {\n      func(...args);\n      lastRan = Date.now();\n    } else {\n      if (lastFunc) {\n        clearTimeout(lastFunc);\n      }\n\n      lastFunc = setTimeout(\n        () => {\n          if (Date.now() - lastRan >= limit) {\n            func(...args);\n            lastRan = Date.now();\n          }\n        },\n        limit - (Date.now() - lastRan),\n      );\n    }\n  };\n}\n\nlet isRunningInReact: boolean | undefined;\n\n/**\n * Not really the most optimal way to detect if we're running in React,\n * but the idea here is that we can support multiple rendering engines\n * (starting with React), with all their peculiarities, without having\n * to add a dependency or creating custom integrations (e.g. custom hooks).\n *\n * Yes, a bit of magic to make things works out-of-the-box.\n * @returns `true` if running in React, `false` otherwise.\n */\nexport function isReact() {\n  if (isRunningInReact === undefined) {\n    const stack = new Error().stack;\n    isRunningInReact =\n      !!stack &&\n      (stack.includes(\"node_modules/react-dom/\") ||\n        stack.includes(\"node_modules/next/\"));\n  }\n  return isRunningInReact;\n}\n\n/**\n * Check if a value is a plain object.\n * @param value - The value to check.\n * @returns `true` if the value is a plain object, `false` otherwise.\n */\nexport function isPlainObject(value: any): boolean {\n  return !!value && Object.getPrototypeOf(value) === Object.prototype;\n}\n", "import { getConfig, getRestApiUrl } from \"./config\";\nimport { dispatchRequest } from \"./request\";\nimport { isPlainObject } from \"./utils\";\n\n/**\n * File support for the client. This interface establishes the contract for\n * uploading files to the server and transforming the input to replace file\n * objects with URLs.\n */\nexport interface StorageSupport {\n  /**\n   * Upload a file to the server. Returns the URL of the uploaded file.\n   * @param file the file to upload\n   * @param options optional parameters, such as custom file name\n   * @returns the URL of the uploaded file\n   */\n  upload: (file: Blob) => Promise<string>;\n\n  /**\n   * Transform the input to replace file objects with URLs. This is used\n   * to transform the input before sending it to the server and ensures\n   * that the server receives URLs instead of file objects.\n   *\n   * @param input the input to transform.\n   * @returns the transformed input.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  transformInput: (input: Record<string, any>) => Promise<Record<string, any>>;\n}\n\ntype InitiateUploadResult = {\n  file_url: string;\n  upload_url: string;\n};\n\ntype InitiateUploadData = {\n  file_name: string;\n  content_type: string | null;\n};\n\n/**\n * Get the file extension from the content type. This is used to generate\n * a file name if the file name is not provided.\n *\n * @param contentType the content type of the file.\n * @returns the file extension or `bin` if the content type is not recognized.\n */\nfunction getExtensionFromContentType(contentType: string): string {\n  const [_, fileType] = contentType.split(\"/\");\n  return fileType.split(/[-;]/)[0] ?? \"bin\";\n}\n\n/**\n * Initiate the upload of a file to the server. This returns the URL to upload\n * the file to and the URL of the file once it is uploaded.\n *\n * @param file the file to upload\n * @returns the URL to upload the file to and the URL of the file once it is uploaded.\n */\nasync function initiateUpload(file: Blob): Promise<InitiateUploadResult> {\n  const contentType = file.type || \"application/octet-stream\";\n  const filename =\n    file.name || `${Date.now()}.${getExtensionFromContentType(contentType)}`;\n  return await dispatchRequest<InitiateUploadData, InitiateUploadResult>(\n    \"POST\",\n    `${getRestApiUrl()}/storage/upload/initiate`,\n    {\n      content_type: contentType,\n      file_name: filename,\n    },\n  );\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype KeyValuePair = [string, any];\n\nexport const storageImpl: StorageSupport = {\n  upload: async (file: Blob) => {\n    const { fetch } = getConfig();\n    const { upload_url: uploadUrl, file_url: url } = await initiateUpload(file);\n    const response = await fetch(uploadUrl, {\n      method: \"PUT\",\n      body: file,\n      headers: {\n        \"Content-Type\": file.type || \"application/octet-stream\",\n      },\n    });\n    const { responseHandler } = getConfig();\n    await responseHandler(response);\n    return url;\n  },\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  transformInput: async (input: any): Promise<any> => {\n    if (Array.isArray(input)) {\n      return Promise.all(input.map((item) => storageImpl.transformInput(item)));\n    } else if (input instanceof Blob) {\n      return await storageImpl.upload(input);\n    } else if (isPlainObject(input)) {\n      const inputObject = input as Record<string, any>;\n      const promises = Object.entries(inputObject).map(\n        async ([key, value]): Promise<KeyValuePair> => {\n          return [key, await storageImpl.transformInput(value)];\n        },\n      );\n      const results = await Promise.all(promises);\n      return Object.fromEntries(results);\n    }\n    // Return the input as is if it's neither an object nor a file/blob/data URI\n    return input;\n  },\n};\n", "/**\n * EventSource/Server-Sent Events parser\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html\n *\n * Based on code from the {@link https://github.com/EventSource/eventsource | EventSource module},\n * which is licensed under the MIT license. And copyrighted the EventSource GitHub organisation.\n */\nimport type {EventSourceParseCallback, EventSourceParser} from './types.js'\n\n/**\n * Creates a new EventSource parser.\n *\n * @param onParse - Callback to invoke when a new event is parsed, or a new reconnection interval\n *                  has been sent from the server\n *\n * @returns A new EventSource parser, with `parse` and `reset` methods.\n * @public\n */\nexport function createParser(onParse: EventSourceParseCallback): EventSourceParser {\n  // Processing state\n  let isFirstChunk: boolean\n  let buffer: string\n  let startingPosition: number\n  let startingFieldLength: number\n\n  // Event state\n  let eventId: string | undefined\n  let eventName: string | undefined\n  let data: string\n\n  reset()\n  return {feed, reset}\n\n  function reset(): void {\n    isFirstChunk = true\n    buffer = ''\n    startingPosition = 0\n    startingFieldLength = -1\n\n    eventId = undefined\n    eventName = undefined\n    data = ''\n  }\n\n  function feed(chunk: string): void {\n    buffer = buffer ? buffer + chunk : chunk\n\n    // Strip any UTF8 byte order mark (BOM) at the start of the stream.\n    // Note that we do not strip any non - UTF8 BOM, as eventsource streams are\n    // always decoded as UTF8 as per the specification.\n    if (isFirstChunk && hasBom(buffer)) {\n      buffer = buffer.slice(BOM.length)\n    }\n\n    isFirstChunk = false\n\n    // Set up chunk-specific processing state\n    const length = buffer.length\n    let position = 0\n    let discardTrailingNewline = false\n\n    // Read the current buffer byte by byte\n    while (position < length) {\n      // EventSource allows for carriage return + line feed, which means we\n      // need to ignore a linefeed character if the previous character was a\n      // carriage return\n      // @todo refactor to reduce nesting, consider checking previous byte?\n      // @todo but consider multiple chunks etc\n      if (discardTrailingNewline) {\n        if (buffer[position] === '\\n') {\n          ++position\n        }\n        discardTrailingNewline = false\n      }\n\n      let lineLength = -1\n      let fieldLength = startingFieldLength\n      let character: string\n\n      for (let index = startingPosition; lineLength < 0 && index < length; ++index) {\n        character = buffer[index]\n        if (character === ':' && fieldLength < 0) {\n          fieldLength = index - position\n        } else if (character === '\\r') {\n          discardTrailingNewline = true\n          lineLength = index - position\n        } else if (character === '\\n') {\n          lineLength = index - position\n        }\n      }\n\n      if (lineLength < 0) {\n        startingPosition = length - position\n        startingFieldLength = fieldLength\n        break\n      } else {\n        startingPosition = 0\n        startingFieldLength = -1\n      }\n\n      parseEventStreamLine(buffer, position, fieldLength, lineLength)\n\n      position += lineLength + 1\n    }\n\n    if (position === length) {\n      // If we consumed the entire buffer to read the event, reset the buffer\n      buffer = ''\n    } else if (position > 0) {\n      // If there are bytes left to process, set the buffer to the unprocessed\n      // portion of the buffer only\n      buffer = buffer.slice(position)\n    }\n  }\n\n  function parseEventStreamLine(\n    lineBuffer: string,\n    index: number,\n    fieldLength: number,\n    lineLength: number,\n  ) {\n    if (lineLength === 0) {\n      // We reached the last line of this event\n      if (data.length > 0) {\n        onParse({\n          type: 'event',\n          id: eventId,\n          event: eventName || undefined,\n          data: data.slice(0, -1), // remove trailing newline\n        })\n\n        data = ''\n        eventId = undefined\n      }\n      eventName = undefined\n      return\n    }\n\n    const noValue = fieldLength < 0\n    const field = lineBuffer.slice(index, index + (noValue ? lineLength : fieldLength))\n    let step = 0\n\n    if (noValue) {\n      step = lineLength\n    } else if (lineBuffer[index + fieldLength + 1] === ' ') {\n      step = fieldLength + 2\n    } else {\n      step = fieldLength + 1\n    }\n\n    const position = index + step\n    const valueLength = lineLength - step\n    const value = lineBuffer.slice(position, position + valueLength).toString()\n\n    if (field === 'data') {\n      data += value ? `${value}\\n` : '\\n'\n    } else if (field === 'event') {\n      eventName = value\n    } else if (field === 'id' && !value.includes('\\u0000')) {\n      eventId = value\n    } else if (field === 'retry') {\n      const retry = parseInt(value, 10)\n      if (!Number.isNaN(retry)) {\n        onParse({type: 'reconnect-interval', value: retry})\n      }\n    }\n  }\n}\n\nconst BOM = [239, 187, 191]\n\nfunction hasBom(buffer: string) {\n  return BOM.every((charCode: number, index: number) => buffer.charCodeAt(index) === charCode)\n}\n", "import { getRestApiUrl } from \"./config\";\nimport { dispatchRequest } from \"./request\";\nimport { parseAppId } from \"./utils\";\n\nexport const TOKEN_EXPIRATION_SECONDS = 120;\n\n/**\n * Get a token to connect to the realtime endpoint.\n */\nexport async function getTemporaryAuthToken(app: string): Promise<string> {\n  const appId = parseAppId(app);\n  const token: string | object = await dispatchRequest<any, string>(\n    \"POST\",\n    `${getRestApiUrl()}/tokens/`,\n    {\n      allowed_apps: [appId.alias],\n      token_expiration: TOKEN_EXPIRATION_SECONDS,\n    },\n  );\n  // keep this in case the response was wrapped (old versions of the proxy do that)\n  // should be safe to remove in the future\n  if (typeof token !== \"string\" && token[\"detail\"]) {\n    return token[\"detail\"];\n  }\n  return token;\n}\n", "import { createParser } from \"eventsource-parser\";\nimport { getTemporaryAuthToken } from \"./auth\";\nimport { getConfig } from \"./config\";\nimport { buildUrl } from \"./function\";\nimport { dispatchRequest } from \"./request\";\nimport { ApiError, defaultResponseHandler } from \"./response\";\nimport { storageImpl } from \"./storage\";\n\nexport type StreamingConnectionMode = \"client\" | \"server\";\n\nconst CONTENT_TYPE_EVENT_STREAM = \"text/event-stream\";\n\n/**\n * The stream API options. It requires the API input and also\n * offers configuration options.\n */\ntype StreamOptions<Input> = {\n  /**\n   * The endpoint URL. If not provided, it will be generated from the\n   * `endpointId` and the `queryParams`.\n   */\n  readonly url?: string;\n\n  /**\n   * The API input payload.\n   */\n  readonly input?: Input;\n\n  /**\n   * The query parameters to be sent with the request.\n   */\n  readonly queryParams?: Record<string, string>;\n\n  /**\n   * The maximum time interval in milliseconds between stream chunks. Defaults to 15s.\n   */\n  readonly timeout?: number;\n\n  /**\n   * Whether it should auto-upload File-like types to fal's storage\n   * or not.\n   */\n  readonly autoUpload?: boolean;\n\n  /**\n   * The HTTP method, defaults to `post`;\n   */\n  readonly method?: \"get\" | \"post\" | \"put\" | \"delete\" | string;\n\n  /**\n   * The content type the client accepts as response.\n   * By default this is set to `text/event-stream`.\n   */\n  readonly accept?: string;\n\n  /**\n   * The streaming connection mode. This is used to determine\n   * whether the streaming will be done from the browser itself (client)\n   * or through your own server, either when running on NodeJS or when\n   * using a proxy that supports streaming.\n   *\n   * It defaults to `server`. Set to `client` if your server proxy doesn't\n   * support streaming.\n   */\n  readonly connectionMode?: StreamingConnectionMode;\n};\n\nconst EVENT_STREAM_TIMEOUT = 15 * 1000;\n\ntype FalStreamEventType = \"data\" | \"error\" | \"done\";\n\ntype EventHandler<T = any> = (event: T) => void;\n\n/**\n * The class representing a streaming response. With t\n */\nexport class FalStream<Input, Output> {\n  // properties\n  endpointId: string;\n  url: string;\n  options: StreamOptions<Input>;\n\n  // support for event listeners\n  private listeners: Map<FalStreamEventType, EventHandler[]> = new Map();\n  private buffer: Output[] = [];\n\n  // local state\n  private currentData: Output | undefined = undefined;\n  private lastEventTimestamp = 0;\n  private streamClosed = false;\n  private donePromise: Promise<Output>;\n\n  private abortController = new AbortController();\n\n  constructor(endpointId: string, options: StreamOptions<Input>) {\n    this.endpointId = endpointId;\n    this.url =\n      options.url ??\n      buildUrl(endpointId, {\n        path: \"/stream\",\n        query: options.queryParams,\n      });\n    this.options = options;\n    this.donePromise = new Promise<Output>((resolve, reject) => {\n      if (this.streamClosed) {\n        reject(\n          new ApiError({\n            message: \"Streaming connection is already closed.\",\n            status: 400,\n            body: undefined,\n          }),\n        );\n      }\n      this.on(\"done\", (data) => {\n        this.streamClosed = true;\n        resolve(data);\n      });\n      this.on(\"error\", (error) => {\n        this.streamClosed = true;\n        reject(error);\n      });\n    });\n    this.start().catch(this.handleError);\n  }\n\n  private start = async () => {\n    const { endpointId, options } = this;\n    const { input, method = \"post\", connectionMode = \"server\" } = options;\n    try {\n      if (connectionMode === \"client\") {\n        // if we are in the browser, we need to get a temporary token\n        // to authenticate the request\n        const token = await getTemporaryAuthToken(endpointId);\n        const { fetch } = getConfig();\n        const parsedUrl = new URL(this.url);\n        parsedUrl.searchParams.set(\"fal_jwt_token\", token);\n        const response = await fetch(parsedUrl.toString(), {\n          method: method.toUpperCase(),\n          headers: {\n            accept: options.accept ?? CONTENT_TYPE_EVENT_STREAM,\n            \"content-type\": \"application/json\",\n          },\n          body: input && method !== \"get\" ? JSON.stringify(input) : undefined,\n          signal: this.abortController.signal,\n        });\n        return await this.handleResponse(response);\n      }\n      return await dispatchRequest(method.toUpperCase(), this.url, input, {\n        headers: {\n          accept: options.accept ?? CONTENT_TYPE_EVENT_STREAM,\n        },\n        responseHandler: this.handleResponse,\n        signal: this.abortController.signal,\n      });\n    } catch (error) {\n      this.handleError(error);\n    }\n  };\n\n  private handleResponse = async (response: Response) => {\n    if (!response.ok) {\n      try {\n        // we know the response failed, call the response handler\n        // so the exception gets converted to ApiError correctly\n        await defaultResponseHandler(response);\n      } catch (error) {\n        this.emit(\"error\", error);\n      }\n      return;\n    }\n\n    const body = response.body;\n    if (!body) {\n      this.emit(\n        \"error\",\n        new ApiError({\n          message: \"Response body is empty.\",\n          status: 400,\n          body: undefined,\n        }),\n      );\n      return;\n    }\n\n    const isEventStream = response.headers\n      .get(\"content-type\")\n      .startsWith(CONTENT_TYPE_EVENT_STREAM);\n    // any response that is not a text/event-stream will be handled as a binary stream\n    if (!isEventStream) {\n      const reader = body.getReader();\n      const emitRawChunk = () => {\n        reader.read().then(({ done, value }) => {\n          if (done) {\n            this.emit(\"done\", this.currentData);\n            return;\n          }\n          this.currentData = value as Output;\n          this.emit(\"data\", value);\n          emitRawChunk();\n        });\n      };\n      emitRawChunk();\n      return;\n    }\n\n    const decoder = new TextDecoder(\"utf-8\");\n    const reader = response.body.getReader();\n\n    const parser = createParser((event) => {\n      if (event.type === \"event\") {\n        const data = event.data;\n\n        try {\n          const parsedData = JSON.parse(data);\n          this.buffer.push(parsedData);\n          this.currentData = parsedData;\n          this.emit(\"data\", parsedData);\n\n          // also emit 'message'for backwards compatibility\n          this.emit(\"message\" as any, parsedData);\n        } catch (e) {\n          this.emit(\"error\", e);\n        }\n      }\n    });\n\n    const timeout = this.options.timeout ?? EVENT_STREAM_TIMEOUT;\n\n    const readPartialResponse = async () => {\n      const { value, done } = await reader.read();\n      this.lastEventTimestamp = Date.now();\n\n      parser.feed(decoder.decode(value));\n\n      if (Date.now() - this.lastEventTimestamp > timeout) {\n        this.emit(\n          \"error\",\n          new ApiError({\n            message: `Event stream timed out after ${(timeout / 1000).toFixed(0)} seconds with no messages.`,\n            status: 408,\n          }),\n        );\n      }\n\n      if (!done) {\n        readPartialResponse().catch(this.handleError);\n      } else {\n        this.emit(\"done\", this.currentData);\n      }\n    };\n\n    readPartialResponse().catch(this.handleError);\n    return;\n  };\n\n  private handleError = (error: any) => {\n    const apiError =\n      error instanceof ApiError\n        ? error\n        : new ApiError({\n            message: error.message ?? \"An unknown error occurred\",\n            status: 500,\n          });\n    this.emit(\"error\", apiError);\n    return;\n  };\n\n  public on = (type: FalStreamEventType, listener: EventHandler) => {\n    if (!this.listeners.has(type)) {\n      this.listeners.set(type, []);\n    }\n    this.listeners.get(type)?.push(listener);\n  };\n\n  private emit = (type: FalStreamEventType, event: any) => {\n    const listeners = this.listeners.get(type) || [];\n    for (const listener of listeners) {\n      listener(event);\n    }\n  };\n\n  async *[Symbol.asyncIterator]() {\n    let running = true;\n    const stopAsyncIterator = () => (running = false);\n    this.on(\"error\", stopAsyncIterator);\n    this.on(\"done\", stopAsyncIterator);\n    while (running) {\n      const data = this.buffer.shift();\n      if (data) {\n        yield data;\n      }\n\n      // the short timeout ensures the while loop doesn't block other\n      // frames getting executed concurrently\n      await new Promise((resolve) => setTimeout(resolve, 16));\n    }\n  }\n\n  /**\n   * Gets a reference to the `Promise` that indicates whether the streaming\n   * is done or not. Developers should always call this in their apps to ensure\n   * the request is over.\n   *\n   * An alternative to this, is to use `on('done')` in case your application\n   * architecture works best with event listeners.\n   *\n   * @returns the promise that resolves when the request is done.\n   */\n  public done = async () => this.donePromise;\n\n  /**\n   * Aborts the streaming request.\n   */\n  public abort = () => {\n    this.abortController.abort();\n  };\n}\n\n/**\n * Calls a fal app that supports streaming and provides a streaming-capable\n * object as a result, that can be used to get partial results through either\n * `AsyncIterator` or through an event listener.\n *\n * @param endpointId the endpoint id, e.g. `fal-ai/llavav15-13b`.\n * @param options the request options, including the input payload.\n * @returns the `FalStream` instance.\n */\nexport async function stream<Input = Record<string, any>, Output = any>(\n  endpointId: string,\n  options: StreamOptions<Input>,\n): Promise<FalStream<Input, Output>> {\n  const input =\n    options.input && options.autoUpload !== false\n      ? await storageImpl.transformInput(options.input)\n      : options.input;\n  return new FalStream<Input, Output>(endpointId, {\n    ...options,\n    input: input as Input,\n  });\n}\n", "import { dispatchRequest } from \"./request\";\nimport { storageImpl } from \"./storage\";\nimport { FalStream, StreamingConnectionMode } from \"./streaming\";\nimport {\n  CompletedQueueStatus,\n  EnqueueResult,\n  QueueStatus,\n  RequestLog,\n} from \"./types\";\nimport { ensureAppIdFormat, isValidUrl, parseAppId } from \"./utils\";\n\n/**\n * The function input and other configuration when running\n * the function, such as the HTTP method to use.\n */\ntype RunOptions<Input> = {\n  /**\n   * The path to the function, if any. Defaults to ``.\n   * @deprecated Pass the path as part of the app id itself, e.g. `fal-ai/sdxl/image-to-image`\n   */\n  readonly path?: string;\n\n  /**\n   * The function input. It will be submitted either as query params\n   * or the body payload, depending on the `method`.\n   */\n  readonly input?: Input;\n\n  /**\n   * The HTTP method, defaults to `post`;\n   */\n  readonly method?: \"get\" | \"post\" | \"put\" | \"delete\" | string;\n\n  /**\n   * If `true`, the function will automatically upload any files\n   * (i.e. instances of `Blob`).\n   *\n   * This is enabled by default. You can disable it by setting it to `false`.\n   */\n  readonly autoUpload?: boolean;\n};\n\ntype ExtraOptions = {\n  /**\n   * If `true`, the function will use the queue to run the function\n   * asynchronously and return the result in a separate call. This\n   * influences how the URL is built.\n   */\n  readonly subdomain?: string;\n\n  /**\n   * The query parameters to include in the URL.\n   */\n  readonly query?: Record<string, string>;\n};\n\n/**\n * Builds the final url to run the function based on its `id` or alias and\n * a the options from `RunOptions<Input>`.\n *\n * @private\n * @param id the function id or alias\n * @param options the run options\n * @returns the final url to run the function\n */\nexport function buildUrl<Input>(\n  id: string,\n  options: RunOptions<Input> & ExtraOptions = {},\n): string {\n  const method = (options.method ?? \"post\").toLowerCase();\n  const path = (options.path ?? \"\").replace(/^\\//, \"\").replace(/\\/{2,}/, \"/\");\n  const input = options.input;\n  const params = {\n    ...(options.query || {}),\n    ...(method === \"get\" ? input : {}),\n  };\n\n  const queryParams =\n    Object.keys(params).length > 0\n      ? `?${new URLSearchParams(params).toString()}`\n      : \"\";\n\n  // if a fal url is passed, just use it\n  if (isValidUrl(id)) {\n    const url = id.endsWith(\"/\") ? id : `${id}/`;\n    return `${url}${path}${queryParams}`;\n  }\n\n  const appId = ensureAppIdFormat(id);\n  const subdomain = options.subdomain ? `${options.subdomain}.` : \"\";\n  const url = `https://${subdomain}fal.run/${appId}/${path}`;\n  return `${url.replace(/\\/$/, \"\")}${queryParams}`;\n}\n\nexport async function send<Input, Output>(\n  id: string,\n  options: RunOptions<Input> & ExtraOptions = {},\n): Promise<Output> {\n  const input =\n    options.input && options.autoUpload !== false\n      ? await storageImpl.transformInput(options.input)\n      : options.input;\n  return dispatchRequest<Input, Output>(\n    options.method ?? \"post\",\n    buildUrl(id, options),\n    input as Input,\n  );\n}\n\nexport type QueueStatusSubscriptionOptions = QueueStatusOptions &\n  Omit<QueueSubscribeOptions, \"onEnqueue\" | \"webhookUrl\">;\n\n/**\n * Runs a fal serverless function identified by its `id`.\n *\n * @param id the registered function revision id or alias.\n * @returns the remote function output\n */\nexport async function run<Input, Output>(\n  id: string,\n  options: RunOptions<Input> = {},\n): Promise<Output> {\n  return send(id, options);\n}\n\ntype TimeoutId = ReturnType<typeof setTimeout> | undefined;\n\nconst DEFAULT_POLL_INTERVAL = 500;\n\n/**\n * Options for subscribing to the request queue.\n */\ntype QueueSubscribeOptions = {\n  /**\n   * The mode to use for subscribing to updates. It defaults to `polling`.\n   * You can also use client-side streaming by setting it to `streaming`.\n   *\n   * **Note:** Streaming is currently experimental and once stable, it will\n   * be the default mode.\n   *\n   * @see pollInterval\n   */\n  mode?: \"polling\" | \"streaming\";\n\n  /**\n   * Callback function that is called when a request is enqueued.\n   * @param requestId - The unique identifier for the enqueued request.\n   */\n  onEnqueue?: (requestId: string) => void;\n\n  /**\n   * Callback function that is called when the status of the queue changes.\n   * @param status - The current status of the queue.\n   */\n  onQueueUpdate?: (status: QueueStatus) => void;\n\n  /**\n   * If `true`, the response will include the logs for the request.\n   * Defaults to `false`.\n   */\n  logs?: boolean;\n\n  /**\n   * The timeout (in milliseconds) for the request. If the request is not\n   * completed within this time, the subscription will be cancelled.\n   *\n   * Keep in mind that although the client resolves the function on a timeout,\n   * and will try to cancel the request on the server, the server might not be\n   * able to cancel the request if it's already running.\n   *\n   * Note: currently, the timeout is not enforced and the default is `undefined`.\n   * This behavior might change in the future.\n   */\n  timeout?: number;\n\n  /**\n   * The URL to send a webhook notification to when the request is completed.\n   * @see WebHookResponse\n   */\n  webhookUrl?: string;\n} & (\n  | {\n      mode?: \"polling\";\n      /**\n       * The interval (in milliseconds) at which to poll for updates.\n       * If not provided, a default value of `500` will be used.\n       *\n       * This value is ignored if `mode` is set to `streaming`.\n       */\n      pollInterval?: number;\n    }\n  | {\n      mode: \"streaming\";\n\n      /**\n       * The connection mode to use for streaming updates. It defaults to `server`.\n       * Set to `client` if your server proxy doesn't support streaming.\n       */\n      connectionMode?: StreamingConnectionMode;\n    }\n);\n\n/**\n * Options for submitting a request to the queue.\n */\ntype SubmitOptions<Input> = RunOptions<Input> & {\n  /**\n   * The URL to send a webhook notification to when the request is completed.\n   * @see WebHookResponse\n   */\n  webhookUrl?: string;\n};\n\ntype BaseQueueOptions = {\n  /**\n   * The unique identifier for the enqueued request.\n   */\n  requestId: string;\n};\n\ntype QueueStatusOptions = BaseQueueOptions & {\n  /**\n   * If `true`, the response will include the logs for the request.\n   * Defaults to `false`.\n   */\n  logs?: boolean;\n};\n\ntype QueueStatusStreamOptions = QueueStatusOptions & {\n  /**\n   * The connection mode to use for streaming updates. It defaults to `server`.\n   * Set to `client` if your server proxy doesn't support streaming.\n   */\n  connectionMode?: StreamingConnectionMode;\n};\n\n/**\n * Represents a request queue with methods for submitting requests,\n * checking their status, retrieving results, and subscribing to updates.\n */\ninterface Queue {\n  /**\n   * Submits a request to the queue.\n   *\n   * @param endpointId - The ID of the function web endpoint.\n   * @param options - Options to configure how the request is run.\n   * @returns A promise that resolves to the result of enqueuing the request.\n   */\n  submit<Input>(\n    endpointId: string,\n    options: SubmitOptions<Input>,\n  ): Promise<EnqueueResult>;\n\n  /**\n   * Retrieves the status of a specific request in the queue.\n   *\n   * @param endpointId - The ID of the function web endpoint.\n   * @param options - Options to configure how the request is run.\n   * @returns A promise that resolves to the status of the request.\n   */\n  status(endpointId: string, options: QueueStatusOptions): Promise<QueueStatus>;\n\n  /**\n   * Subscribes to updates for a specific request in the queue using HTTP streaming events.\n   *\n   * @param endpointId - The ID of the function web endpoint.\n   * @param options - Options to configure how the request is run and how updates are received.\n   * @returns The streaming object that can be used to listen for updates.\n   */\n  streamStatus(\n    endpointId: string,\n    options: QueueStatusStreamOptions,\n  ): Promise<FalStream<unknown, QueueStatus>>;\n\n  /**\n   * Subscribes to updates for a specific request in the queue using polling or streaming.\n   * See `options.mode` for more details.\n   *\n   * @param endpointId - The ID of the function web endpoint.\n   * @param options - Options to configure how the request is run and how updates are received.\n   * @returns A promise that resolves to the final status of the request.\n   */\n  subscribeToStatus(\n    endpointId: string,\n    options: QueueStatusSubscriptionOptions,\n  ): Promise<CompletedQueueStatus>;\n\n  /**\n   * Retrieves the result of a specific request from the queue.\n   *\n   * @param endpointId - The ID of the function web endpoint.\n   * @param options - Options to configure how the request is run.\n   * @returns A promise that resolves to the result of the request.\n   */\n  result<Output>(\n    endpointId: string,\n    options: BaseQueueOptions,\n  ): Promise<Output>;\n\n  /**\n   * Cancels a request in the queue.\n   *\n   * @param endpointId - The ID of the function web endpoint.\n   * @param options - Options to configure how the request\n   * is run and how updates are received.\n   * @returns A promise that resolves once the request is cancelled.\n   * @throws {Error} If the request cannot be cancelled.\n   */\n  cancel(endpointId: string, options: BaseQueueOptions): Promise<void>;\n}\n\n/**\n * The fal run queue module. It allows to submit a function to the queue and get its result\n * on a separate call. This is useful for long running functions that can be executed\n * asynchronously and not .\n */\nexport const queue: Queue = {\n  async submit<Input>(\n    endpointId: string,\n    options: SubmitOptions<Input>,\n  ): Promise<EnqueueResult> {\n    const { webhookUrl, path = \"\", ...runOptions } = options;\n    return send(endpointId, {\n      ...runOptions,\n      subdomain: \"queue\",\n      method: \"post\",\n      path: path,\n      query: webhookUrl ? { fal_webhook: webhookUrl } : undefined,\n    });\n  },\n  async status(\n    endpointId: string,\n    { requestId, logs = false }: QueueStatusOptions,\n  ): Promise<QueueStatus> {\n    const appId = parseAppId(endpointId);\n    const prefix = appId.namespace ? `${appId.namespace}/` : \"\";\n    return send(`${prefix}${appId.owner}/${appId.alias}`, {\n      subdomain: \"queue\",\n      method: \"get\",\n      path: `/requests/${requestId}/status`,\n      input: {\n        logs: logs ? \"1\" : \"0\",\n      },\n    });\n  },\n\n  async streamStatus(\n    endpointId: string,\n    { requestId, logs = false, connectionMode }: QueueStatusStreamOptions,\n  ): Promise<FalStream<unknown, QueueStatus>> {\n    const appId = parseAppId(endpointId);\n    const prefix = appId.namespace ? `${appId.namespace}/` : \"\";\n\n    const queryParams = {\n      logs: logs ? \"1\" : \"0\",\n    };\n\n    const url = buildUrl(`${prefix}${appId.owner}/${appId.alias}`, {\n      subdomain: \"queue\",\n      path: `/requests/${requestId}/status/stream`,\n      query: queryParams,\n    });\n\n    return new FalStream<unknown, QueueStatus>(endpointId, {\n      url,\n      method: \"get\",\n      connectionMode,\n      queryParams,\n    });\n  },\n\n  async subscribeToStatus(endpointId, options): Promise<CompletedQueueStatus> {\n    const requestId = options.requestId;\n    const timeout = options.timeout;\n    let timeoutId: TimeoutId = undefined;\n\n    const handleCancelError = () => {\n      // Ignore errors as the client will follow through with the timeout\n      // regardless of the server response. In case cancelation fails, we\n      // still want to reject the promise and consider the client call canceled.\n    };\n    if (options.mode === \"streaming\") {\n      const status = await queue.streamStatus(endpointId, {\n        requestId,\n        logs: options.logs,\n        connectionMode:\n          \"connectionMode\" in options\n            ? (options.connectionMode as StreamingConnectionMode)\n            : undefined,\n      });\n      const logs: RequestLog[] = [];\n      if (timeout) {\n        timeoutId = setTimeout(() => {\n          status.abort();\n          queue.cancel(endpointId, { requestId }).catch(handleCancelError);\n          // TODO this error cannot bubble up to the user since it's thrown in\n          // a closure in the global scope due to setTimeout behavior.\n          // User will get a platform error instead. We should find a way to\n          // make this behavior aligned with polling.\n          throw new Error(\n            `Client timed out waiting for the request to complete after ${timeout}ms`,\n          );\n        }, timeout);\n      }\n      status.on(\"data\", (data: QueueStatus) => {\n        if (options.onQueueUpdate) {\n          // accumulate logs to match previous polling behavior\n          if (\n            \"logs\" in data &&\n            Array.isArray(data.logs) &&\n            data.logs.length > 0\n          ) {\n            logs.push(...data.logs);\n          }\n          options.onQueueUpdate(\"logs\" in data ? { ...data, logs } : data);\n        }\n      });\n      const doneStatus = await status.done();\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n      return doneStatus as CompletedQueueStatus;\n    }\n    // default to polling until status streaming is stable and faster\n    return new Promise<CompletedQueueStatus>((resolve, reject) => {\n      let pollingTimeoutId: TimeoutId;\n      // type resolution isn't great in this case, so check for its presence\n      // and and type so the typechecker behaves as expected\n      const pollInterval =\n        \"pollInterval\" in options && typeof options.pollInterval === \"number\"\n          ? (options.pollInterval ?? DEFAULT_POLL_INTERVAL)\n          : DEFAULT_POLL_INTERVAL;\n\n      const clearScheduledTasks = () => {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n        }\n        if (pollingTimeoutId) {\n          clearTimeout(pollingTimeoutId);\n        }\n      };\n      if (timeout) {\n        timeoutId = setTimeout(() => {\n          clearScheduledTasks();\n          queue.cancel(endpointId, { requestId }).catch(handleCancelError);\n          reject(\n            new Error(\n              `Client timed out waiting for the request to complete after ${timeout}ms`,\n            ),\n          );\n        }, timeout);\n      }\n      const poll = async () => {\n        try {\n          const requestStatus = await queue.status(endpointId, {\n            requestId,\n            logs: options.logs ?? false,\n          });\n          if (options.onQueueUpdate) {\n            options.onQueueUpdate(requestStatus);\n          }\n          if (requestStatus.status === \"COMPLETED\") {\n            clearScheduledTasks();\n            resolve(requestStatus);\n            return;\n          }\n          pollingTimeoutId = setTimeout(poll, pollInterval);\n        } catch (error) {\n          clearScheduledTasks();\n          reject(error);\n        }\n      };\n      poll().catch(reject);\n    });\n  },\n\n  async result<Output>(\n    endpointId: string,\n    { requestId }: BaseQueueOptions,\n  ): Promise<Output> {\n    const appId = parseAppId(endpointId);\n    const prefix = appId.namespace ? `${appId.namespace}/` : \"\";\n    return send(`${prefix}${appId.owner}/${appId.alias}`, {\n      subdomain: \"queue\",\n      method: \"get\",\n      path: `/requests/${requestId}`,\n    });\n  },\n\n  async cancel(\n    endpointId: string,\n    { requestId }: BaseQueueOptions,\n  ): Promise<void> {\n    const appId = parseAppId(endpointId);\n    const prefix = appId.namespace ? `${appId.namespace}/` : \"\";\n    await send(`${prefix}${appId.owner}/${appId.alias}`, {\n      subdomain: \"queue\",\n      method: \"put\",\n      path: `/requests/${requestId}/cancel`,\n    });\n  },\n};\n\n/**\n * Subscribes to updates for a specific request in the queue.\n *\n * @param endpointId - The ID of the function web endpoint.\n * @param options - Options to configure how the request is run and how updates are received.\n * @returns A promise that resolves to the result of the request once it's completed.\n */\nexport async function subscribe<Input, Output>(\n  endpointId: string,\n  options: RunOptions<Input> & QueueSubscribeOptions = {},\n): Promise<Output> {\n  const { request_id: requestId } = await queue.submit(endpointId, options);\n  if (options.onEnqueue) {\n    options.onEnqueue(requestId);\n  }\n  await queue.subscribeToStatus(endpointId, { requestId, ...options });\n  return queue.result(endpointId, { requestId });\n}\n", "\nexport function utf8Count(str: string): number {\n  const strLength = str.length;\n\n  let byteLength = 0;\n  let pos = 0;\n  while (pos < strLength) {\n    let value = str.charCodeAt(pos++);\n\n    if ((value & 0xffffff80) === 0) {\n      // 1-byte\n      byteLength++;\n      continue;\n    } else if ((value & 0xfffff800) === 0) {\n      // 2-bytes\n      byteLength += 2;\n    } else {\n      // handle surrogate pair\n      if (value >= 0xd800 && value <= 0xdbff) {\n        // high surrogate\n        if (pos < strLength) {\n          const extra = str.charCodeAt(pos);\n          if ((extra & 0xfc00) === 0xdc00) {\n            ++pos;\n            value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n          }\n        }\n      }\n\n      if ((value & 0xffff0000) === 0) {\n        // 3-byte\n        byteLength += 3;\n      } else {\n        // 4-byte\n        byteLength += 4;\n      }\n    }\n  }\n  return byteLength;\n}\n\nexport function utf8EncodeJs(str: string, output: Uint8Array, outputOffset: number): void {\n  const strLength = str.length;\n  let offset = outputOffset;\n  let pos = 0;\n  while (pos < strLength) {\n    let value = str.charCodeAt(pos++);\n\n    if ((value & 0xffffff80) === 0) {\n      // 1-byte\n      output[offset++] = value;\n      continue;\n    } else if ((value & 0xfffff800) === 0) {\n      // 2-bytes\n      output[offset++] = ((value >> 6) & 0x1f) | 0xc0;\n    } else {\n      // handle surrogate pair\n      if (value >= 0xd800 && value <= 0xdbff) {\n        // high surrogate\n        if (pos < strLength) {\n          const extra = str.charCodeAt(pos);\n          if ((extra & 0xfc00) === 0xdc00) {\n            ++pos;\n            value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n          }\n        }\n      }\n\n      if ((value & 0xffff0000) === 0) {\n        // 3-byte\n        output[offset++] = ((value >> 12) & 0x0f) | 0xe0;\n        output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n      } else {\n        // 4-byte\n        output[offset++] = ((value >> 18) & 0x07) | 0xf0;\n        output[offset++] = ((value >> 12) & 0x3f) | 0x80;\n        output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n      }\n    }\n\n    output[offset++] = (value & 0x3f) | 0x80;\n  }\n}\n\n// TextEncoder and TextDecoder are standardized in whatwg encoding:\n// https://encoding.spec.whatwg.org/\n// and available in all the modern browsers:\n// https://caniuse.com/textencoder\n// They are available in Node.js since v12 LTS as well:\n// https://nodejs.org/api/globals.html#textencoder\n\nconst sharedTextEncoder = new TextEncoder();\n\n// This threshold should be determined by benchmarking, which might vary in engines and input data.\n// Run `npx ts-node benchmark/encode-string.ts` for details.\nconst TEXT_ENCODER_THRESHOLD = 50;\n\nexport function utf8EncodeTE(str: string, output: Uint8Array, outputOffset: number): void {\n  sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));\n}\n\nexport function utf8Encode(str: string, output: Uint8Array, outputOffset: number): void {\n  if (str.length > TEXT_ENCODER_THRESHOLD) {\n    utf8EncodeTE(str, output, outputOffset);\n  } else {\n    utf8EncodeJs(str, output, outputOffset);\n  }\n}\n\nconst CHUNK_SIZE = 0x1_000;\n\nexport function utf8DecodeJs(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\n  let offset = inputOffset;\n  const end = offset + byteLength;\n\n  const units: Array<number> = [];\n  let result = \"\";\n  while (offset < end) {\n    const byte1 = bytes[offset++]!;\n    if ((byte1 & 0x80) === 0) {\n      // 1 byte\n      units.push(byte1);\n    } else if ((byte1 & 0xe0) === 0xc0) {\n      // 2 bytes\n      const byte2 = bytes[offset++]! & 0x3f;\n      units.push(((byte1 & 0x1f) << 6) | byte2);\n    } else if ((byte1 & 0xf0) === 0xe0) {\n      // 3 bytes\n      const byte2 = bytes[offset++]! & 0x3f;\n      const byte3 = bytes[offset++]! & 0x3f;\n      units.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);\n    } else if ((byte1 & 0xf8) === 0xf0) {\n      // 4 bytes\n      const byte2 = bytes[offset++]! & 0x3f;\n      const byte3 = bytes[offset++]! & 0x3f;\n      const byte4 = bytes[offset++]! & 0x3f;\n      let unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;\n      if (unit > 0xffff) {\n        unit -= 0x10000;\n        units.push(((unit >>> 10) & 0x3ff) | 0xd800);\n        unit = 0xdc00 | (unit & 0x3ff);\n      }\n      units.push(unit);\n    } else {\n      units.push(byte1);\n    }\n\n    if (units.length >= CHUNK_SIZE) {\n      result += String.fromCharCode(...units);\n      units.length = 0;\n    }\n  }\n\n  if (units.length > 0) {\n    result += String.fromCharCode(...units);\n  }\n\n  return result;\n}\n\nconst sharedTextDecoder = new TextDecoder();\n\n// This threshold should be determined by benchmarking, which might vary in engines and input data.\n// Run `npx ts-node benchmark/decode-string.ts` for details.\nconst TEXT_DECODER_THRESHOLD = 200;\n\nexport function utf8DecodeTD(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\n  const stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);\n  return sharedTextDecoder.decode(stringBytes);\n}\n\nexport function utf8Decode(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\n  if (byteLength > TEXT_DECODER_THRESHOLD) {\n    return utf8DecodeTD(bytes, inputOffset, byteLength);\n  } else {\n    return utf8DecodeJs(bytes, inputOffset, byteLength);\n  }\n}\n", "/**\n * ExtData is used to handle Extension Types that are not registered to ExtensionCodec.\n */\nexport class ExtData {\n  constructor(readonly type: number, readonly data: Uint8Array) {}\n}\n", "export class DecodeError extends Error {\n  constructor(message: string) {\n    super(message);\n\n    // fix the prototype chain in a cross-platform way\n    const proto: typeof DecodeError.prototype = Object.create(DecodeError.prototype);\n    Object.setPrototypeOf(this, proto);\n\n    Object.defineProperty(this, \"name\", {\n      configurable: true,\n      enumerable: false,\n      value: DecodeError.name,\n    });\n  }\n}\n", "// Integer Utility\n\nexport const UINT32_MAX = 0xffff_ffff;\n\n// DataView extension to handle int64 / uint64,\n// where the actual range is 53-bits integer (a.k.a. safe integer)\n\nexport function setUint64(view: DataView, offset: number, value: number): void {\n  const high = value / 0x1_0000_0000;\n  const low = value; // high bits are truncated by DataView\n  view.setUint32(offset, high);\n  view.setUint32(offset + 4, low);\n}\n\nexport function setInt64(view: DataView, offset: number, value: number): void {\n  const high = Math.floor(value / 0x1_0000_0000);\n  const low = value; // high bits are truncated by DataView\n  view.setUint32(offset, high);\n  view.setUint32(offset + 4, low);\n}\n\nexport function getInt64(view: DataView, offset: number): number {\n  const high = view.getInt32(offset);\n  const low = view.getUint32(offset + 4);\n  return high * 0x1_0000_0000 + low;\n}\n\nexport function getUint64(view: DataView, offset: number): number {\n  const high = view.getUint32(offset);\n  const low = view.getUint32(offset + 4);\n  return high * 0x1_0000_0000 + low;\n}\n", "// https://github.com/msgpack/msgpack/blob/master/spec.md#timestamp-extension-type\nimport { DecodeError } from \"./DecodeError\";\nimport { getInt64, setInt64 } from \"./utils/int\";\n\nexport const EXT_TIMESTAMP = -1;\n\nexport type TimeSpec = {\n  sec: number;\n  nsec: number;\n};\n\nconst TIMESTAMP32_MAX_SEC = 0x100000000 - 1; // 32-bit unsigned int\nconst TIMESTAMP64_MAX_SEC = 0x400000000 - 1; // 34-bit unsigned int\n\nexport function encodeTimeSpecToTimestamp({ sec, nsec }: TimeSpec): Uint8Array {\n  if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {\n    // Here sec >= 0 && nsec >= 0\n    if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {\n      // timestamp 32 = { sec32 (unsigned) }\n      const rv = new Uint8Array(4);\n      const view = new DataView(rv.buffer);\n      view.setUint32(0, sec);\n      return rv;\n    } else {\n      // timestamp 64 = { nsec30 (unsigned), sec34 (unsigned) }\n      const secHigh = sec / 0x100000000;\n      const secLow = sec & 0xffffffff;\n      const rv = new Uint8Array(8);\n      const view = new DataView(rv.buffer);\n      // nsec30 | secHigh2\n      view.setUint32(0, (nsec << 2) | (secHigh & 0x3));\n      // secLow32\n      view.setUint32(4, secLow);\n      return rv;\n    }\n  } else {\n    // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n    const rv = new Uint8Array(12);\n    const view = new DataView(rv.buffer);\n    view.setUint32(0, nsec);\n    setInt64(view, 4, sec);\n    return rv;\n  }\n}\n\nexport function encodeDateToTimeSpec(date: Date): TimeSpec {\n  const msec = date.getTime();\n  const sec = Math.floor(msec / 1e3);\n  const nsec = (msec - sec * 1e3) * 1e6;\n\n  // Normalizes { sec, nsec } to ensure nsec is unsigned.\n  const nsecInSec = Math.floor(nsec / 1e9);\n  return {\n    sec: sec + nsecInSec,\n    nsec: nsec - nsecInSec * 1e9,\n  };\n}\n\nexport function encodeTimestampExtension(object: unknown): Uint8Array | null {\n  if (object instanceof Date) {\n    const timeSpec = encodeDateToTimeSpec(object);\n    return encodeTimeSpecToTimestamp(timeSpec);\n  } else {\n    return null;\n  }\n}\n\nexport function decodeTimestampToTimeSpec(data: Uint8Array): TimeSpec {\n  const view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n\n  // data may be 32, 64, or 96 bits\n  switch (data.byteLength) {\n    case 4: {\n      // timestamp 32 = { sec32 }\n      const sec = view.getUint32(0);\n      const nsec = 0;\n      return { sec, nsec };\n    }\n    case 8: {\n      // timestamp 64 = { nsec30, sec34 }\n      const nsec30AndSecHigh2 = view.getUint32(0);\n      const secLow32 = view.getUint32(4);\n      const sec = (nsec30AndSecHigh2 & 0x3) * 0x100000000 + secLow32;\n      const nsec = nsec30AndSecHigh2 >>> 2;\n      return { sec, nsec };\n    }\n    case 12: {\n      // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n\n      const sec = getInt64(view, 4);\n      const nsec = view.getUint32(0);\n      return { sec, nsec };\n    }\n    default:\n      throw new DecodeError(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${data.length}`);\n  }\n}\n\nexport function decodeTimestampExtension(data: Uint8Array): Date {\n  const timeSpec = decodeTimestampToTimeSpec(data);\n  return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);\n}\n\nexport const timestampExtension = {\n  type: EXT_TIMESTAMP,\n  encode: encodeTimestampExtension,\n  decode: decodeTimestampExtension,\n};\n", "// ExtensionCodec to handle MessagePack extensions\n\nimport { ExtData } from \"./ExtData\";\nimport { timestampExtension } from \"./timestamp\";\n\nexport type ExtensionDecoderType<ContextType> = (\n  data: Uint8Array,\n  extensionType: number,\n  context: ContextType,\n) => unknown;\n\nexport type ExtensionEncoderType<ContextType> = (input: unknown, context: ContextType) => Uint8Array | null;\n\n// immutable interface to ExtensionCodec\nexport type ExtensionCodecType<ContextType> = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  __brand?: ContextType;\n  tryToEncode(object: unknown, context: ContextType): ExtData | null;\n  decode(data: Uint8Array, extType: number, context: ContextType): unknown;\n};\n\nexport class ExtensionCodec<ContextType = undefined> implements ExtensionCodecType<ContextType> {\n  public static readonly defaultCodec: ExtensionCodecType<undefined> = new ExtensionCodec();\n\n  // ensures ExtensionCodecType<X> matches ExtensionCodec<X>\n  // this will make type errors a lot more clear\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  __brand?: ContextType;\n\n  // built-in extensions\n  private readonly builtInEncoders: Array<ExtensionEncoderType<ContextType> | undefined | null> = [];\n  private readonly builtInDecoders: Array<ExtensionDecoderType<ContextType> | undefined | null> = [];\n\n  // custom extensions\n  private readonly encoders: Array<ExtensionEncoderType<ContextType> | undefined | null> = [];\n  private readonly decoders: Array<ExtensionDecoderType<ContextType> | undefined | null> = [];\n\n  public constructor() {\n    this.register(timestampExtension);\n  }\n\n  public register({\n    type,\n    encode,\n    decode,\n  }: {\n    type: number;\n    encode: ExtensionEncoderType<ContextType>;\n    decode: ExtensionDecoderType<ContextType>;\n  }): void {\n    if (type >= 0) {\n      // custom extensions\n      this.encoders[type] = encode;\n      this.decoders[type] = decode;\n    } else {\n      // built-in extensions\n      const index = 1 + type;\n      this.builtInEncoders[index] = encode;\n      this.builtInDecoders[index] = decode;\n    }\n  }\n\n  public tryToEncode(object: unknown, context: ContextType): ExtData | null {\n    // built-in extensions\n    for (let i = 0; i < this.builtInEncoders.length; i++) {\n      const encodeExt = this.builtInEncoders[i];\n      if (encodeExt != null) {\n        const data = encodeExt(object, context);\n        if (data != null) {\n          const type = -1 - i;\n          return new ExtData(type, data);\n        }\n      }\n    }\n\n    // custom extensions\n    for (let i = 0; i < this.encoders.length; i++) {\n      const encodeExt = this.encoders[i];\n      if (encodeExt != null) {\n        const data = encodeExt(object, context);\n        if (data != null) {\n          const type = i;\n          return new ExtData(type, data);\n        }\n      }\n    }\n\n    if (object instanceof ExtData) {\n      // to keep ExtData as is\n      return object;\n    }\n    return null;\n  }\n\n  public decode(data: Uint8Array, type: number, context: ContextType): unknown {\n    const decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];\n    if (decodeExt) {\n      return decodeExt(data, type, context);\n    } else {\n      // decode() does not fail, returns ExtData instead.\n      return new ExtData(type, data);\n    }\n  }\n}\n", "export function ensureUint8Array(buffer: ArrayLike<number> | Uint8Array | ArrayBufferView | ArrayBuffer): Uint8Array {\n  if (buffer instanceof Uint8Array) {\n    return buffer;\n  } else if (ArrayBuffer.isView(buffer)) {\n    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  } else if (buffer instanceof ArrayBuffer) {\n    return new Uint8Array(buffer);\n  } else {\n    // ArrayLike<number>\n    return Uint8Array.from(buffer);\n  }\n}\n\nexport function createDataView(buffer: ArrayLike<number> | ArrayBufferView | ArrayBuffer): DataView {\n  if (buffer instanceof ArrayBuffer) {\n    return new DataView(buffer);\n  }\n\n  const bufferView = ensureUint8Array(buffer);\n  return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\n}\n", "import { utf8Count, utf8Encode } from \"./utils/utf8\";\nimport { ExtensionCodec, ExtensionCodecType } from \"./ExtensionCodec\";\nimport { setInt64, setUint64 } from \"./utils/int\";\nimport { ensureUint8Array } from \"./utils/typedArrays\";\nimport type { ExtData } from \"./ExtData\";\nimport type { ContextOf } from \"./context\";\n\n\nexport const DEFAULT_MAX_DEPTH = 100;\nexport const DEFAULT_INITIAL_BUFFER_SIZE = 2048;\n\nexport type EncoderOptions<ContextType = undefined> = Partial<\n  Readonly<{\n    extensionCodec: ExtensionCodecType<ContextType>;\n\n    /**\n     * Encodes bigint as Int64 or Uint64 if it's set to true.\n     * {@link forceIntegerToFloat} does not affect bigint.\n     * Depends on ES2020's {@link DataView#setBigInt64} and\n     * {@link DataView#setBigUint64}.\n     *\n     * Defaults to false.\n     */\n    useBigInt64: boolean;\n\n    /**\n     * The maximum depth in nested objects and arrays.\n     *\n     * Defaults to 100.\n     */\n    maxDepth: number;\n\n    /**\n     * The initial size of the internal buffer.\n     *\n     * Defaults to 2048.\n     */\n    initialBufferSize: number;\n\n    /**\n     * If `true`, the keys of an object is sorted. In other words, the encoded\n     * binary is canonical and thus comparable to another encoded binary.\n     *\n     * Defaults to `false`. If enabled, it spends more time in encoding objects.\n     */\n    sortKeys: boolean;\n    /**\n     * If `true`, non-integer numbers are encoded in float32, not in float64 (the default).\n     *\n     * Only use it if precisions don't matter.\n     *\n     * Defaults to `false`.\n     */\n    forceFloat32: boolean;\n\n    /**\n     * If `true`, an object property with `undefined` value are ignored.\n     * e.g. `{ foo: undefined }` will be encoded as `{}`, as `JSON.stringify()` does.\n     *\n     * Defaults to `false`. If enabled, it spends more time in encoding objects.\n     */\n    ignoreUndefined: boolean;\n\n    /**\n     * If `true`, integer numbers are encoded as floating point numbers,\n     * with the `forceFloat32` option taken into account.\n     *\n     * Defaults to `false`.\n     */\n    forceIntegerToFloat: boolean;\n  }>\n> & ContextOf<ContextType>;\n\nexport class Encoder<ContextType = undefined> {\n  private readonly extensionCodec: ExtensionCodecType<ContextType>;\n  private readonly context: ContextType;\n  private readonly useBigInt64: boolean;\n  private readonly maxDepth: number;\n  private readonly initialBufferSize: number;\n  private readonly sortKeys: boolean;\n  private readonly forceFloat32: boolean;\n  private readonly ignoreUndefined: boolean;\n  private readonly forceIntegerToFloat: boolean;\n\n  private pos: number;\n  private view: DataView;\n  private bytes: Uint8Array;\n\n  public constructor(options?: EncoderOptions<ContextType>) {\n    this.extensionCodec = options?.extensionCodec ?? (ExtensionCodec.defaultCodec as ExtensionCodecType<ContextType>);\n    this.context = (options as { context: ContextType } | undefined)?.context as ContextType; // needs a type assertion because EncoderOptions has no context property when ContextType is undefined\n\n    this.useBigInt64 = options?.useBigInt64 ?? false;\n    this.maxDepth = options?.maxDepth ?? DEFAULT_MAX_DEPTH;\n    this.initialBufferSize = options?.initialBufferSize ?? DEFAULT_INITIAL_BUFFER_SIZE;\n    this.sortKeys = options?.sortKeys ?? false;\n    this.forceFloat32 = options?.forceFloat32 ?? false;\n    this.ignoreUndefined = options?.ignoreUndefined ?? false;\n    this.forceIntegerToFloat = options?.forceIntegerToFloat ?? false;\n\n    this.pos = 0;\n    this.view = new DataView(new ArrayBuffer(this.initialBufferSize));\n    this.bytes = new Uint8Array(this.view.buffer);\n  }\n\n  private reinitializeState() {\n    this.pos = 0;\n  }\n\n  /**\n   * This is almost equivalent to {@link Encoder#encode}, but it returns an reference of the encoder's internal buffer and thus much faster than {@link Encoder#encode}.\n   *\n   * @returns Encodes the object and returns a shared reference the encoder's internal buffer.\n   */\n  public encodeSharedRef(object: unknown): Uint8Array {\n    this.reinitializeState();\n    this.doEncode(object, 1);\n    return this.bytes.subarray(0, this.pos);\n  }\n\n  /**\n   * @returns Encodes the object and returns a copy of the encoder's internal buffer.\n   */\n  public encode(object: unknown): Uint8Array {\n    this.reinitializeState();\n    this.doEncode(object, 1);\n    return this.bytes.slice(0, this.pos);\n  }\n\n  private doEncode(object: unknown, depth: number): void {\n    if (depth > this.maxDepth) {\n      throw new Error(`Too deep objects in depth ${depth}`);\n    }\n\n    if (object == null) {\n      this.encodeNil();\n    } else if (typeof object === \"boolean\") {\n      this.encodeBoolean(object);\n    } else if (typeof object === \"number\") {\n      if (!this.forceIntegerToFloat) {\n        this.encodeNumber(object);\n      } else {\n        this.encodeNumberAsFloat(object);\n      }\n    } else if (typeof object === \"string\") {\n      this.encodeString(object);\n    } else if (this.useBigInt64 && typeof object === \"bigint\") {\n      this.encodeBigInt64(object);\n    } else {\n      this.encodeObject(object, depth);\n    }\n  }\n\n  private ensureBufferSizeToWrite(sizeToWrite: number) {\n    const requiredSize = this.pos + sizeToWrite;\n\n    if (this.view.byteLength < requiredSize) {\n      this.resizeBuffer(requiredSize * 2);\n    }\n  }\n\n  private resizeBuffer(newSize: number) {\n    const newBuffer = new ArrayBuffer(newSize);\n    const newBytes = new Uint8Array(newBuffer);\n    const newView = new DataView(newBuffer);\n\n    newBytes.set(this.bytes);\n\n    this.view = newView;\n    this.bytes = newBytes;\n  }\n\n  private encodeNil() {\n    this.writeU8(0xc0);\n  }\n\n  private encodeBoolean(object: boolean) {\n    if (object === false) {\n      this.writeU8(0xc2);\n    } else {\n      this.writeU8(0xc3);\n    }\n  }\n\n  private encodeNumber(object: number): void {\n    if (!this.forceIntegerToFloat && Number.isSafeInteger(object)) {\n      if (object >= 0) {\n        if (object < 0x80) {\n          // positive fixint\n          this.writeU8(object);\n        } else if (object < 0x100) {\n          // uint 8\n          this.writeU8(0xcc);\n          this.writeU8(object);\n        } else if (object < 0x10000) {\n          // uint 16\n          this.writeU8(0xcd);\n          this.writeU16(object);\n        } else if (object < 0x100000000) {\n          // uint 32\n          this.writeU8(0xce);\n          this.writeU32(object);\n        } else if (!this.useBigInt64) {\n          // uint 64\n          this.writeU8(0xcf);\n          this.writeU64(object);\n        } else {\n          this.encodeNumberAsFloat(object);\n        }\n      } else {\n        if (object >= -0x20) {\n          // negative fixint\n          this.writeU8(0xe0 | (object + 0x20));\n        } else if (object >= -0x80) {\n          // int 8\n          this.writeU8(0xd0);\n          this.writeI8(object);\n        } else if (object >= -0x8000) {\n          // int 16\n          this.writeU8(0xd1);\n          this.writeI16(object);\n        } else if (object >= -0x80000000) {\n          // int 32\n          this.writeU8(0xd2);\n          this.writeI32(object);\n        } else if (!this.useBigInt64) {\n          // int 64\n          this.writeU8(0xd3);\n          this.writeI64(object);\n        } else {\n          this.encodeNumberAsFloat(object);\n        }\n      }\n    } else {\n      this.encodeNumberAsFloat(object);\n    }\n  }\n\n  private encodeNumberAsFloat(object: number): void {\n    if (this.forceFloat32) {\n      // float 32\n      this.writeU8(0xca);\n      this.writeF32(object);\n    } else {\n      // float 64\n      this.writeU8(0xcb);\n      this.writeF64(object);\n    }\n  }\n\n  private encodeBigInt64(object: bigint): void {\n    if (object >= BigInt(0)) {\n      // uint 64\n      this.writeU8(0xcf);\n      this.writeBigUint64(object);\n    } else {\n      // int 64\n      this.writeU8(0xd3);\n      this.writeBigInt64(object);\n    }\n  }\n\n  private writeStringHeader(byteLength: number) {\n    if (byteLength < 32) {\n      // fixstr\n      this.writeU8(0xa0 + byteLength);\n    } else if (byteLength < 0x100) {\n      // str 8\n      this.writeU8(0xd9);\n      this.writeU8(byteLength);\n    } else if (byteLength < 0x10000) {\n      // str 16\n      this.writeU8(0xda);\n      this.writeU16(byteLength);\n    } else if (byteLength < 0x100000000) {\n      // str 32\n      this.writeU8(0xdb);\n      this.writeU32(byteLength);\n    } else {\n      throw new Error(`Too long string: ${byteLength} bytes in UTF-8`);\n    }\n  }\n\n  private encodeString(object: string) {\n    const maxHeaderSize = 1 + 4;\n\n    const byteLength = utf8Count(object);\n    this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n    this.writeStringHeader(byteLength);\n    utf8Encode(object, this.bytes, this.pos);\n    this.pos += byteLength;\n  }\n\n  private encodeObject(object: unknown, depth: number) {\n    // try to encode objects with custom codec first of non-primitives\n    const ext = this.extensionCodec.tryToEncode(object, this.context);\n    if (ext != null) {\n      this.encodeExtension(ext);\n    } else if (Array.isArray(object)) {\n      this.encodeArray(object, depth);\n    } else if (ArrayBuffer.isView(object)) {\n      this.encodeBinary(object);\n    } else if (typeof object === \"object\") {\n      this.encodeMap(object as Record<string, unknown>, depth);\n    } else {\n      // symbol, function and other special object come here unless extensionCodec handles them.\n      throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(object)}`);\n    }\n  }\n\n  private encodeBinary(object: ArrayBufferView) {\n    const size = object.byteLength;\n    if (size < 0x100) {\n      // bin 8\n      this.writeU8(0xc4);\n      this.writeU8(size);\n    } else if (size < 0x10000) {\n      // bin 16\n      this.writeU8(0xc5);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // bin 32\n      this.writeU8(0xc6);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large binary: ${size}`);\n    }\n    const bytes = ensureUint8Array(object);\n    this.writeU8a(bytes);\n  }\n\n  private encodeArray(object: Array<unknown>, depth: number) {\n    const size = object.length;\n    if (size < 16) {\n      // fixarray\n      this.writeU8(0x90 + size);\n    } else if (size < 0x10000) {\n      // array 16\n      this.writeU8(0xdc);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // array 32\n      this.writeU8(0xdd);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large array: ${size}`);\n    }\n    for (const item of object) {\n      this.doEncode(item, depth + 1);\n    }\n  }\n\n  private countWithoutUndefined(object: Record<string, unknown>, keys: ReadonlyArray<string>): number {\n    let count = 0;\n\n    for (const key of keys) {\n      if (object[key] !== undefined) {\n        count++;\n      }\n    }\n\n    return count;\n  }\n\n  private encodeMap(object: Record<string, unknown>, depth: number) {\n    const keys = Object.keys(object);\n    if (this.sortKeys) {\n      keys.sort();\n    }\n\n    const size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;\n\n    if (size < 16) {\n      // fixmap\n      this.writeU8(0x80 + size);\n    } else if (size < 0x10000) {\n      // map 16\n      this.writeU8(0xde);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // map 32\n      this.writeU8(0xdf);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large map object: ${size}`);\n    }\n\n    for (const key of keys) {\n      const value = object[key];\n\n      if (!(this.ignoreUndefined && value === undefined)) {\n        this.encodeString(key);\n        this.doEncode(value, depth + 1);\n      }\n    }\n  }\n\n  private encodeExtension(ext: ExtData) {\n    const size = ext.data.length;\n    if (size === 1) {\n      // fixext 1\n      this.writeU8(0xd4);\n    } else if (size === 2) {\n      // fixext 2\n      this.writeU8(0xd5);\n    } else if (size === 4) {\n      // fixext 4\n      this.writeU8(0xd6);\n    } else if (size === 8) {\n      // fixext 8\n      this.writeU8(0xd7);\n    } else if (size === 16) {\n      // fixext 16\n      this.writeU8(0xd8);\n    } else if (size < 0x100) {\n      // ext 8\n      this.writeU8(0xc7);\n      this.writeU8(size);\n    } else if (size < 0x10000) {\n      // ext 16\n      this.writeU8(0xc8);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // ext 32\n      this.writeU8(0xc9);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large extension object: ${size}`);\n    }\n    this.writeI8(ext.type);\n    this.writeU8a(ext.data);\n  }\n\n  private writeU8(value: number) {\n    this.ensureBufferSizeToWrite(1);\n\n    this.view.setUint8(this.pos, value);\n    this.pos++;\n  }\n\n  private writeU8a(values: ArrayLike<number>) {\n    const size = values.length;\n    this.ensureBufferSizeToWrite(size);\n\n    this.bytes.set(values, this.pos);\n    this.pos += size;\n  }\n\n  private writeI8(value: number) {\n    this.ensureBufferSizeToWrite(1);\n\n    this.view.setInt8(this.pos, value);\n    this.pos++;\n  }\n\n  private writeU16(value: number) {\n    this.ensureBufferSizeToWrite(2);\n\n    this.view.setUint16(this.pos, value);\n    this.pos += 2;\n  }\n\n  private writeI16(value: number) {\n    this.ensureBufferSizeToWrite(2);\n\n    this.view.setInt16(this.pos, value);\n    this.pos += 2;\n  }\n\n  private writeU32(value: number) {\n    this.ensureBufferSizeToWrite(4);\n\n    this.view.setUint32(this.pos, value);\n    this.pos += 4;\n  }\n\n  private writeI32(value: number) {\n    this.ensureBufferSizeToWrite(4);\n\n    this.view.setInt32(this.pos, value);\n    this.pos += 4;\n  }\n\n  private writeF32(value: number) {\n    this.ensureBufferSizeToWrite(4);\n\n    this.view.setFloat32(this.pos, value);\n    this.pos += 4;\n  }\n\n  private writeF64(value: number) {\n    this.ensureBufferSizeToWrite(8);\n\n    this.view.setFloat64(this.pos, value);\n    this.pos += 8;\n  }\n\n  private writeU64(value: number) {\n    this.ensureBufferSizeToWrite(8);\n\n    setUint64(this.view, this.pos, value);\n    this.pos += 8;\n  }\n\n  private writeI64(value: number) {\n    this.ensureBufferSizeToWrite(8);\n\n    setInt64(this.view, this.pos, value);\n    this.pos += 8;\n  }\n\n  private writeBigUint64(value: bigint) {\n    this.ensureBufferSizeToWrite(8);\n\n    this.view.setBigUint64(this.pos, value);\n    this.pos += 8;\n  }\n\n  private writeBigInt64(value: bigint) {\n    this.ensureBufferSizeToWrite(8);\n\n    this.view.setBigInt64(this.pos, value);\n    this.pos += 8;\n  }\n}\n", "import { Encoder } from \"./Encoder\";\nimport type { EncoderOptions } from \"./Encoder\";\nimport type { SplitUndefined } from \"./context\";\n\n/**\n * @deprecated Use {@link EncoderOptions} instead.\n */\nexport type EncodeOptions = never;\n\n/**\n * @deprecated No longer supported.\n */\nexport const defaultEncodeOptions: never = undefined as never;\n\n/**\n * It encodes `value` in the MessagePack format and\n * returns a byte buffer.\n *\n * The returned buffer is a slice of a larger `ArrayBuffer`, so you have to use its `#byteOffset` and `#byteLength` in order to convert it to another typed arrays including NodeJS `Buffer`.\n */\nexport function encode<ContextType = undefined>(\n  value: unknown,\n  options?: EncoderOptions<SplitUndefined<ContextType>>,\n): Uint8Array {\n  const encoder = new Encoder(options);\n  return encoder.encodeSharedRef(value);\n}\n", "export function prettyByte(byte: number): string {\n  return `${byte < 0 ? \"-\" : \"\"}0x${Math.abs(byte).toString(16).padStart(2, \"0\")}`;\n}\n", "import { utf8DecodeJs } from \"./utils/utf8\";\n\nconst DEFAULT_MAX_KEY_LENGTH = 16;\nconst DEFAULT_MAX_LENGTH_PER_KEY = 16;\n\nexport interface KeyDecoder {\n  canBeCached(byteLength: number): boolean;\n  decode(bytes: Uint8Array, inputOffset: number, byteLength: number): string;\n}\ninterface KeyCacheRecord {\n  readonly bytes: Uint8Array;\n  readonly str: string;\n}\n\nexport class CachedKeyDecoder implements KeyDecoder {\n  hit = 0;\n  miss = 0;\n  private readonly caches: Array<Array<KeyCacheRecord>>;\n\n  constructor(readonly maxKeyLength = DEFAULT_MAX_KEY_LENGTH, readonly maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY) {\n    // avoid `new Array(N)`, which makes a sparse array,\n    // because a sparse array is typically slower than a non-sparse array.\n    this.caches = [];\n    for (let i = 0; i < this.maxKeyLength; i++) {\n      this.caches.push([]);\n    }\n  }\n\n  public canBeCached(byteLength: number): boolean {\n    return byteLength > 0 && byteLength <= this.maxKeyLength;\n  }\n\n  private find(bytes: Uint8Array, inputOffset: number, byteLength: number): string | null {\n    const records = this.caches[byteLength - 1]!;\n\n    FIND_CHUNK: for (const record of records) {\n      const recordBytes = record.bytes;\n\n      for (let j = 0; j < byteLength; j++) {\n        if (recordBytes[j] !== bytes[inputOffset + j]) {\n          continue FIND_CHUNK;\n        }\n      }\n      return record.str;\n    }\n    return null;\n  }\n\n  private store(bytes: Uint8Array, value: string) {\n    const records = this.caches[bytes.length - 1]!;\n    const record: KeyCacheRecord = { bytes, str: value };\n\n    if (records.length >= this.maxLengthPerKey) {\n      // `records` are full!\n      // Set `record` to an arbitrary position.\n      records[(Math.random() * records.length) | 0] = record;\n    } else {\n      records.push(record);\n    }\n  }\n\n  public decode(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\n    const cachedValue = this.find(bytes, inputOffset, byteLength);\n    if (cachedValue != null) {\n      this.hit++;\n      return cachedValue;\n    }\n    this.miss++;\n\n    const str = utf8DecodeJs(bytes, inputOffset, byteLength);\n    // Ensure to copy a slice of bytes because the byte may be NodeJS Buffer and Buffer#slice() returns a reference to its internal ArrayBuffer.\n    const slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\n    this.store(slicedCopyOfBytes, str);\n    return str;\n  }\n}\n", "import { prettyByte } from \"./utils/prettyByte\";\nimport { ExtensionCodec, ExtensionCodecType } from \"./ExtensionCodec\";\nimport { getInt64, getUint64, UINT32_MAX } from \"./utils/int\";\nimport { utf8Decode } from \"./utils/utf8\";\nimport { createDataView, ensureUint8Array } from \"./utils/typedArrays\";\nimport { CachedKeyDecoder, KeyDecoder } from \"./CachedKeyDecoder\";\nimport { DecodeError } from \"./DecodeError\";\nimport type { ContextOf } from \"./context\";\n\nexport type DecoderOptions<ContextType = undefined> = Readonly<\n  Partial<{\n    extensionCodec: ExtensionCodecType<ContextType>;\n\n    /**\n     * Decodes Int64 and Uint64 as bigint if it's set to true.\n     * Depends on ES2020's {@link DataView#getBigInt64} and\n     * {@link DataView#getBigUint64}.\n     *\n     * Defaults to false.\n     */\n    useBigInt64: boolean;\n\n    /**\n     * Maximum string length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxStrLength: number;\n    /**\n     * Maximum binary length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxBinLength: number;\n    /**\n     * Maximum array length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxArrayLength: number;\n    /**\n     * Maximum map length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxMapLength: number;\n    /**\n     * Maximum extension length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxExtLength: number;\n\n    /**\n     * An object key decoder. Defaults to the shared instance of {@link CachedKeyDecoder}.\n     * `null` is a special value to disable the use of the key decoder at all.\n     */\n    keyDecoder: KeyDecoder | null;\n  }>\n> &\n  ContextOf<ContextType>;\n\n\nconst STATE_ARRAY = \"array\";\nconst STATE_MAP_KEY = \"map_key\";\nconst STATE_MAP_VALUE = \"map_value\";\n\ntype MapKeyType = string | number;\n\nconst isValidMapKeyType = (key: unknown): key is MapKeyType => {\n  return typeof key === \"string\" || typeof key === \"number\";\n};\n\ntype StackMapState = {\n  type: typeof STATE_MAP_KEY | typeof STATE_MAP_VALUE;\n  size: number;\n  key: MapKeyType | null;\n  readCount: number;\n  map: Record<string, unknown>;\n};\n\ntype StackArrayState = {\n  type: typeof STATE_ARRAY;\n  size: number;\n  array: Array<unknown>;\n  position: number;\n};\n\ntype StackState = StackArrayState | StackMapState;\n\nconst HEAD_BYTE_REQUIRED = -1;\n\nconst EMPTY_VIEW = new DataView(new ArrayBuffer(0));\nconst EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);\n\ntry {\n  // IE11: The spec says it should throw RangeError,\n  // IE11: but in IE11 it throws TypeError.\n  EMPTY_VIEW.getInt8(0);\n} catch (e) {\n  if (!(e instanceof RangeError)) {\n    throw new Error(\"This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access\");\n  }\n}\nexport const DataViewIndexOutOfBoundsError = RangeError;\n\nconst MORE_DATA = new DataViewIndexOutOfBoundsError(\"Insufficient data\");\n\nconst sharedCachedKeyDecoder = new CachedKeyDecoder();\n\nexport class Decoder<ContextType = undefined> {\n  private readonly extensionCodec: ExtensionCodecType<ContextType>;\n  private readonly context: ContextType;\n  private readonly useBigInt64: boolean;\n  private readonly maxStrLength: number;\n  private readonly maxBinLength: number;\n  private readonly maxArrayLength: number;\n  private readonly maxMapLength: number;\n  private readonly maxExtLength: number;\n  private readonly keyDecoder: KeyDecoder | null;\n\n  private totalPos = 0;\n  private pos = 0;\n\n  private view = EMPTY_VIEW;\n  private bytes = EMPTY_BYTES;\n  private headByte = HEAD_BYTE_REQUIRED;\n  private readonly stack: Array<StackState> = [];\n\n  public constructor(options?: DecoderOptions<ContextType>) {\n    this.extensionCodec = options?.extensionCodec ?? (ExtensionCodec.defaultCodec as ExtensionCodecType<ContextType>);\n    this.context = (options as { context: ContextType } | undefined)?.context as ContextType; // needs a type assertion because EncoderOptions has no context property when ContextType is undefined\n\n    this.useBigInt64 = options?.useBigInt64 ?? false;\n    this.maxStrLength = options?.maxStrLength ?? UINT32_MAX;\n    this.maxBinLength = options?.maxBinLength ?? UINT32_MAX;\n    this.maxArrayLength = options?.maxArrayLength ?? UINT32_MAX;\n    this.maxMapLength = options?.maxMapLength ?? UINT32_MAX;\n    this.maxExtLength = options?.maxExtLength ?? UINT32_MAX;\n    this.keyDecoder = (options?.keyDecoder !== undefined) ? options.keyDecoder : sharedCachedKeyDecoder;\n  }\n\n  private reinitializeState() {\n    this.totalPos = 0;\n    this.headByte = HEAD_BYTE_REQUIRED;\n    this.stack.length = 0;\n\n    // view, bytes, and pos will be re-initialized in setBuffer()\n  }\n\n  private setBuffer(buffer: ArrayLike<number> | BufferSource): void {\n    this.bytes = ensureUint8Array(buffer);\n    this.view = createDataView(this.bytes);\n    this.pos = 0;\n  }\n\n  private appendBuffer(buffer: ArrayLike<number> | BufferSource) {\n    if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {\n      this.setBuffer(buffer);\n    } else {\n      const remainingData = this.bytes.subarray(this.pos);\n      const newData = ensureUint8Array(buffer);\n\n      // concat remainingData + newData\n      const newBuffer = new Uint8Array(remainingData.length + newData.length);\n      newBuffer.set(remainingData);\n      newBuffer.set(newData, remainingData.length);\n      this.setBuffer(newBuffer);\n    }\n  }\n\n  private hasRemaining(size: number) {\n    return this.view.byteLength - this.pos >= size;\n  }\n\n  private createExtraByteError(posToShow: number): Error {\n    const { view, pos } = this;\n    return new RangeError(`Extra ${view.byteLength - pos} of ${view.byteLength} byte(s) found at buffer[${posToShow}]`);\n  }\n\n  /**\n   * @throws {@link DecodeError}\n   * @throws {@link RangeError}\n   */\n  public decode(buffer: ArrayLike<number> | BufferSource): unknown {\n    this.reinitializeState();\n    this.setBuffer(buffer);\n\n    const object = this.doDecodeSync();\n    if (this.hasRemaining(1)) {\n      throw this.createExtraByteError(this.pos);\n    }\n    return object;\n  }\n\n  public *decodeMulti(buffer: ArrayLike<number> | BufferSource): Generator<unknown, void, unknown> {\n    this.reinitializeState();\n    this.setBuffer(buffer);\n\n    while (this.hasRemaining(1)) {\n      yield this.doDecodeSync();\n    }\n  }\n\n  public async decodeAsync(stream: AsyncIterable<ArrayLike<number> | BufferSource>): Promise<unknown> {\n    let decoded = false;\n    let object: unknown;\n    for await (const buffer of stream) {\n      if (decoded) {\n        throw this.createExtraByteError(this.totalPos);\n      }\n\n      this.appendBuffer(buffer);\n\n      try {\n        object = this.doDecodeSync();\n        decoded = true;\n      } catch (e) {\n        if (!(e instanceof DataViewIndexOutOfBoundsError)) {\n          throw e; // rethrow\n        }\n        // fallthrough\n      }\n      this.totalPos += this.pos;\n    }\n\n    if (decoded) {\n      if (this.hasRemaining(1)) {\n        throw this.createExtraByteError(this.totalPos);\n      }\n      return object;\n    }\n\n    const { headByte, pos, totalPos } = this;\n    throw new RangeError(\n      `Insufficient data in parsing ${prettyByte(headByte)} at ${totalPos} (${pos} in the current buffer)`,\n    );\n  }\n\n  public decodeArrayStream(\n    stream: AsyncIterable<ArrayLike<number> | BufferSource>,\n  ): AsyncGenerator<unknown, void, unknown> {\n    return this.decodeMultiAsync(stream, true);\n  }\n\n  public decodeStream(stream: AsyncIterable<ArrayLike<number> | BufferSource>): AsyncGenerator<unknown, void, unknown> {\n    return this.decodeMultiAsync(stream, false);\n  }\n\n  private async *decodeMultiAsync(stream: AsyncIterable<ArrayLike<number> | BufferSource>, isArray: boolean) {\n    let isArrayHeaderRequired = isArray;\n    let arrayItemsLeft = -1;\n\n    for await (const buffer of stream) {\n      if (isArray && arrayItemsLeft === 0) {\n        throw this.createExtraByteError(this.totalPos);\n      }\n\n      this.appendBuffer(buffer);\n\n      if (isArrayHeaderRequired) {\n        arrayItemsLeft = this.readArraySize();\n        isArrayHeaderRequired = false;\n        this.complete();\n      }\n\n      try {\n        while (true) {\n          yield this.doDecodeSync();\n          if (--arrayItemsLeft === 0) {\n            break;\n          }\n        }\n      } catch (e) {\n        if (!(e instanceof DataViewIndexOutOfBoundsError)) {\n          throw e; // rethrow\n        }\n        // fallthrough\n      }\n      this.totalPos += this.pos;\n    }\n  }\n\n  private doDecodeSync(): unknown {\n    DECODE: while (true) {\n      const headByte = this.readHeadByte();\n      let object: unknown;\n\n      if (headByte >= 0xe0) {\n        // negative fixint (111x xxxx) 0xe0 - 0xff\n        object = headByte - 0x100;\n      } else if (headByte < 0xc0) {\n        if (headByte < 0x80) {\n          // positive fixint (0xxx xxxx) 0x00 - 0x7f\n          object = headByte;\n        } else if (headByte < 0x90) {\n          // fixmap (1000 xxxx) 0x80 - 0x8f\n          const size = headByte - 0x80;\n          if (size !== 0) {\n            this.pushMapState(size);\n            this.complete();\n            continue DECODE;\n          } else {\n            object = {};\n          }\n        } else if (headByte < 0xa0) {\n          // fixarray (1001 xxxx) 0x90 - 0x9f\n          const size = headByte - 0x90;\n          if (size !== 0) {\n            this.pushArrayState(size);\n            this.complete();\n            continue DECODE;\n          } else {\n            object = [];\n          }\n        } else {\n          // fixstr (101x xxxx) 0xa0 - 0xbf\n          const byteLength = headByte - 0xa0;\n          object = this.decodeUtf8String(byteLength, 0);\n        }\n      } else if (headByte === 0xc0) {\n        // nil\n        object = null;\n      } else if (headByte === 0xc2) {\n        // false\n        object = false;\n      } else if (headByte === 0xc3) {\n        // true\n        object = true;\n      } else if (headByte === 0xca) {\n        // float 32\n        object = this.readF32();\n      } else if (headByte === 0xcb) {\n        // float 64\n        object = this.readF64();\n      } else if (headByte === 0xcc) {\n        // uint 8\n        object = this.readU8();\n      } else if (headByte === 0xcd) {\n        // uint 16\n        object = this.readU16();\n      } else if (headByte === 0xce) {\n        // uint 32\n        object = this.readU32();\n      } else if (headByte === 0xcf) {\n        // uint 64\n        if (this.useBigInt64) {\n          object = this.readU64AsBigInt();\n        } else {\n          object = this.readU64();\n        }\n      } else if (headByte === 0xd0) {\n        // int 8\n        object = this.readI8();\n      } else if (headByte === 0xd1) {\n        // int 16\n        object = this.readI16();\n      } else if (headByte === 0xd2) {\n        // int 32\n        object = this.readI32();\n      } else if (headByte === 0xd3) {\n        // int 64\n        if (this.useBigInt64) {\n          object = this.readI64AsBigInt();\n        } else {\n          object = this.readI64();\n        }\n      } else if (headByte === 0xd9) {\n        // str 8\n        const byteLength = this.lookU8();\n        object = this.decodeUtf8String(byteLength, 1);\n      } else if (headByte === 0xda) {\n        // str 16\n        const byteLength = this.lookU16();\n        object = this.decodeUtf8String(byteLength, 2);\n      } else if (headByte === 0xdb) {\n        // str 32\n        const byteLength = this.lookU32();\n        object = this.decodeUtf8String(byteLength, 4);\n      } else if (headByte === 0xdc) {\n        // array 16\n        const size = this.readU16();\n        if (size !== 0) {\n          this.pushArrayState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = [];\n        }\n      } else if (headByte === 0xdd) {\n        // array 32\n        const size = this.readU32();\n        if (size !== 0) {\n          this.pushArrayState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = [];\n        }\n      } else if (headByte === 0xde) {\n        // map 16\n        const size = this.readU16();\n        if (size !== 0) {\n          this.pushMapState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = {};\n        }\n      } else if (headByte === 0xdf) {\n        // map 32\n        const size = this.readU32();\n        if (size !== 0) {\n          this.pushMapState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = {};\n        }\n      } else if (headByte === 0xc4) {\n        // bin 8\n        const size = this.lookU8();\n        object = this.decodeBinary(size, 1);\n      } else if (headByte === 0xc5) {\n        // bin 16\n        const size = this.lookU16();\n        object = this.decodeBinary(size, 2);\n      } else if (headByte === 0xc6) {\n        // bin 32\n        const size = this.lookU32();\n        object = this.decodeBinary(size, 4);\n      } else if (headByte === 0xd4) {\n        // fixext 1\n        object = this.decodeExtension(1, 0);\n      } else if (headByte === 0xd5) {\n        // fixext 2\n        object = this.decodeExtension(2, 0);\n      } else if (headByte === 0xd6) {\n        // fixext 4\n        object = this.decodeExtension(4, 0);\n      } else if (headByte === 0xd7) {\n        // fixext 8\n        object = this.decodeExtension(8, 0);\n      } else if (headByte === 0xd8) {\n        // fixext 16\n        object = this.decodeExtension(16, 0);\n      } else if (headByte === 0xc7) {\n        // ext 8\n        const size = this.lookU8();\n        object = this.decodeExtension(size, 1);\n      } else if (headByte === 0xc8) {\n        // ext 16\n        const size = this.lookU16();\n        object = this.decodeExtension(size, 2);\n      } else if (headByte === 0xc9) {\n        // ext 32\n        const size = this.lookU32();\n        object = this.decodeExtension(size, 4);\n      } else {\n        throw new DecodeError(`Unrecognized type byte: ${prettyByte(headByte)}`);\n      }\n\n      this.complete();\n\n      const stack = this.stack;\n      while (stack.length > 0) {\n        // arrays and maps\n        const state = stack[stack.length - 1]!;\n        if (state.type === STATE_ARRAY) {\n          state.array[state.position] = object;\n          state.position++;\n          if (state.position === state.size) {\n            stack.pop();\n            object = state.array;\n          } else {\n            continue DECODE;\n          }\n        } else if (state.type === STATE_MAP_KEY) {\n          if (!isValidMapKeyType(object)) {\n            throw new DecodeError(\"The type of key must be string or number but \" + typeof object);\n          }\n          if (object === \"__proto__\") {\n            throw new DecodeError(\"The key __proto__ is not allowed\");\n          }\n\n          state.key = object;\n          state.type = STATE_MAP_VALUE;\n          continue DECODE;\n        } else {\n          // it must be `state.type === State.MAP_VALUE` here\n\n          state.map[state.key!] = object;\n          state.readCount++;\n\n          if (state.readCount === state.size) {\n            stack.pop();\n            object = state.map;\n          } else {\n            state.key = null;\n            state.type = STATE_MAP_KEY;\n            continue DECODE;\n          }\n        }\n      }\n\n      return object;\n    }\n  }\n\n  private readHeadByte(): number {\n    if (this.headByte === HEAD_BYTE_REQUIRED) {\n      this.headByte = this.readU8();\n      // console.log(\"headByte\", prettyByte(this.headByte));\n    }\n\n    return this.headByte;\n  }\n\n  private complete(): void {\n    this.headByte = HEAD_BYTE_REQUIRED;\n  }\n\n  private readArraySize(): number {\n    const headByte = this.readHeadByte();\n\n    switch (headByte) {\n      case 0xdc:\n        return this.readU16();\n      case 0xdd:\n        return this.readU32();\n      default: {\n        if (headByte < 0xa0) {\n          return headByte - 0x90;\n        } else {\n          throw new DecodeError(`Unrecognized array type byte: ${prettyByte(headByte)}`);\n        }\n      }\n    }\n  }\n\n  private pushMapState(size: number) {\n    if (size > this.maxMapLength) {\n      throw new DecodeError(`Max length exceeded: map length (${size}) > maxMapLengthLength (${this.maxMapLength})`);\n    }\n\n    this.stack.push({\n      type: STATE_MAP_KEY,\n      size,\n      key: null,\n      readCount: 0,\n      map: {},\n    });\n  }\n\n  private pushArrayState(size: number) {\n    if (size > this.maxArrayLength) {\n      throw new DecodeError(`Max length exceeded: array length (${size}) > maxArrayLength (${this.maxArrayLength})`);\n    }\n\n    this.stack.push({\n      type: STATE_ARRAY,\n      size,\n      array: new Array<unknown>(size),\n      position: 0,\n    });\n  }\n\n  private decodeUtf8String(byteLength: number, headerOffset: number): string {\n    if (byteLength > this.maxStrLength) {\n      throw new DecodeError(\n        `Max length exceeded: UTF-8 byte length (${byteLength}) > maxStrLength (${this.maxStrLength})`,\n      );\n    }\n\n    if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {\n      throw MORE_DATA;\n    }\n\n    const offset = this.pos + headerOffset;\n    let object: string;\n    if (this.stateIsMapKey() && this.keyDecoder?.canBeCached(byteLength)) {\n      object = this.keyDecoder.decode(this.bytes, offset, byteLength);\n    } else {\n      object = utf8Decode(this.bytes, offset, byteLength);\n    }\n    this.pos += headerOffset + byteLength;\n    return object;\n  }\n\n  private stateIsMapKey(): boolean {\n    if (this.stack.length > 0) {\n      const state = this.stack[this.stack.length - 1]!;\n      return state.type === STATE_MAP_KEY;\n    }\n    return false;\n  }\n\n  private decodeBinary(byteLength: number, headOffset: number): Uint8Array {\n    if (byteLength > this.maxBinLength) {\n      throw new DecodeError(`Max length exceeded: bin length (${byteLength}) > maxBinLength (${this.maxBinLength})`);\n    }\n\n    if (!this.hasRemaining(byteLength + headOffset)) {\n      throw MORE_DATA;\n    }\n\n    const offset = this.pos + headOffset;\n    const object = this.bytes.subarray(offset, offset + byteLength);\n    this.pos += headOffset + byteLength;\n    return object;\n  }\n\n  private decodeExtension(size: number, headOffset: number): unknown {\n    if (size > this.maxExtLength) {\n      throw new DecodeError(`Max length exceeded: ext length (${size}) > maxExtLength (${this.maxExtLength})`);\n    }\n\n    const extType = this.view.getInt8(this.pos + headOffset);\n    const data = this.decodeBinary(size, headOffset + 1 /* extType */);\n    return this.extensionCodec.decode(data, extType, this.context);\n  }\n\n  private lookU8() {\n    return this.view.getUint8(this.pos);\n  }\n\n  private lookU16() {\n    return this.view.getUint16(this.pos);\n  }\n\n  private lookU32() {\n    return this.view.getUint32(this.pos);\n  }\n\n  private readU8(): number {\n    const value = this.view.getUint8(this.pos);\n    this.pos++;\n    return value;\n  }\n\n  private readI8(): number {\n    const value = this.view.getInt8(this.pos);\n    this.pos++;\n    return value;\n  }\n\n  private readU16(): number {\n    const value = this.view.getUint16(this.pos);\n    this.pos += 2;\n    return value;\n  }\n\n  private readI16(): number {\n    const value = this.view.getInt16(this.pos);\n    this.pos += 2;\n    return value;\n  }\n\n  private readU32(): number {\n    const value = this.view.getUint32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n\n  private readI32(): number {\n    const value = this.view.getInt32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n\n  private readU64(): number {\n    const value = getUint64(this.view, this.pos);\n    this.pos += 8;\n    return value;\n  }\n\n  private readI64(): number {\n    const value = getInt64(this.view, this.pos);\n    this.pos += 8;\n    return value;\n  }\n\n  private readU64AsBigInt(): bigint {\n    const value = this.view.getBigUint64(this.pos);\n    this.pos += 8;\n    return value;\n  }\n\n  private readI64AsBigInt(): bigint {\n    const value = this.view.getBigInt64(this.pos);\n    this.pos += 8;\n    return value;\n  }\n\n  private readF32() {\n    const value = this.view.getFloat32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n\n  private readF64() {\n    const value = this.view.getFloat64(this.pos);\n    this.pos += 8;\n    return value;\n  }\n}\n", "import { Decoder } from \"./Decoder\";\nimport type { DecoderOptions } from \"./Decoder\";\nimport type { SplitUndefined } from \"./context\";\n\n/**\n * @deprecated Use {@link DecoderOptions} instead.\n */\nexport type DecodeOptions = never;\n\n/**\n * @deprecated No longer supported.\n */\nexport const defaultDecodeOptions: never = undefined as never;\n\n/**\n * It decodes a single MessagePack object in a buffer.\n *\n * This is a synchronous decoding function.\n * See other variants for asynchronous decoding: {@link decodeAsync()}, {@link decodeStream()}, or {@link decodeArrayStream()}.\n *\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nexport function decode<ContextType = undefined>(\n  buffer: ArrayLike<number> | BufferSource,\n  options?: DecoderOptions<SplitUndefined<ContextType>>,\n): unknown {\n  const decoder = new Decoder(options);\n  return decoder.decode(buffer);\n}\n\n/**\n * It decodes multiple MessagePack objects in a buffer.\n * This is corresponding to {@link decodeMultiStream()}.\n *\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nexport function decodeMulti<ContextType = undefined>(\n  buffer: ArrayLike<number> | BufferSource,\n  options?: DecoderOptions<SplitUndefined<ContextType>>,\n): Generator<unknown, void, unknown> {\n  const decoder = new Decoder(options);\n  return decoder.decodeMulti(buffer);\n}\n", "// utility for whatwg streams\n\n// The living standard of whatwg streams says\n// ReadableStream is also AsyncIterable, but\n// as of June 2019, no browser implements it.\n// See https://streams.spec.whatwg.org/ for details\nexport type ReadableStreamLike<T> = AsyncIterable<T> | ReadableStream<T>;\n\nexport function isAsyncIterable<T>(object: ReadableStreamLike<T>): object is AsyncIterable<T> {\n  return (object as any)[Symbol.asyncIterator] != null;\n}\n\nfunction assertNonNull<T>(value: T | null | undefined): asserts value is T {\n  if (value == null) {\n    throw new Error(\"Assertion Failure: value must not be null nor undefined\");\n  }\n}\n\nexport async function* asyncIterableFromStream<T>(stream: ReadableStream<T>): AsyncIterable<T> {\n  const reader = stream.getReader();\n\n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) {\n        return;\n      }\n      assertNonNull(value);\n      yield value;\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\nexport function ensureAsyncIterable<T>(streamLike: ReadableStreamLike<T>): AsyncIterable<T> {\n  if (isAsyncIterable(streamLike)) {\n    return streamLike;\n  } else {\n    return asyncIterableFromStream(streamLike);\n  }\n}\n", "import { Decoder } from \"./Decoder\";\nimport { ensureAsyncIterable } from \"./utils/stream\";\nimport type { DecoderOptions } from \"./Decoder\";\nimport type { ReadableStreamLike } from \"./utils/stream\";\nimport type { SplitUndefined } from \"./context\";\n\n/**\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\n export async function decodeAsync<ContextType = undefined>(\n  streamLike: ReadableStreamLike<ArrayLike<number> | BufferSource>,\n  options?: DecoderOptions<SplitUndefined<ContextType>>,\n): Promise<unknown> {\n  const stream = ensureAsyncIterable(streamLike);\n  const decoder = new Decoder(options);\n  return decoder.decodeAsync(stream);\n}\n\n/**\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\n export function decodeArrayStream<ContextType>(\n  streamLike: ReadableStreamLike<ArrayLike<number> | BufferSource>,\n  options?: DecoderOptions<SplitUndefined<ContextType>>,\n): AsyncGenerator<unknown, void, unknown> {\n  const stream = ensureAsyncIterable(streamLike);\n  const decoder = new Decoder(options);\n  return decoder.decodeArrayStream(stream);\n}\n\n/**\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nexport function decodeMultiStream<ContextType>(\n  streamLike: ReadableStreamLike<ArrayLike<number> | BufferSource>,\n  options?: DecoderOptions<SplitUndefined<ContextType>>,\n): AsyncGenerator<unknown, void, unknown> {\n  const stream = ensureAsyncIterable(streamLike);\n  const decoder = new Decoder(options);\n  return decoder.decodeStream(stream);\n}\n\n/**\n * @deprecated Use {@link decodeMultiStream()} instead.\n */\nexport const decodeStream: never = undefined as never;\n", "// Main Functions:\n\nimport { encode } from \"./encode\";\nexport { encode };\nimport type { EncodeOptions } from \"./encode\";\nexport type { EncodeOptions };\n\nimport { decode, decodeMulti } from \"./decode\";\nexport { decode, decodeMulti };\nimport type { DecodeOptions } from \"./decode\";\nexport { DecodeOptions };\n\nimport { decodeAsync, decodeArrayStream, decodeMultiStream, decodeStream } from \"./decodeAsync\";\nexport { decodeAsync, decodeArrayStream, decodeMultiStream, decodeStream };\n\nimport { Decoder, DataViewIndexOutOfBoundsError } from \"./Decoder\";\nexport { Decoder, DataViewIndexOutOfBoundsError };\nimport type { DecoderOptions } from \"./Decoder\";\nexport type { DecoderOptions };\nimport { DecodeError } from \"./DecodeError\";\nexport { DecodeError };\n\nimport { Encoder } from \"./Encoder\";\nexport { Encoder };\nimport type { EncoderOptions } from \"./Encoder\";\nexport type { EncoderOptions };\n\n// Utilities for Extension Types:\n\nimport { ExtensionCodec } from \"./ExtensionCodec\";\nexport { ExtensionCodec };\nimport type { ExtensionCodecType, ExtensionDecoderType, ExtensionEncoderType } from \"./ExtensionCodec\";\nexport type { ExtensionCodecType, ExtensionDecoderType, ExtensionEncoderType };\nimport { ExtData } from \"./ExtData\";\nexport { ExtData };\n\nimport {\n  EXT_TIMESTAMP,\n  encodeDateToTimeSpec,\n  encodeTimeSpecToTimestamp,\n  decodeTimestampToTimeSpec,\n  encodeTimestampExtension,\n  decodeTimestampExtension,\n} from \"./timestamp\";\nexport {\n  EXT_TIMESTAMP,\n  encodeDateToTimeSpec,\n  encodeTimeSpecToTimestamp,\n  decodeTimestampToTimeSpec,\n  encodeTimestampExtension,\n  decodeTimestampExtension,\n};\n", "'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction valueEnumerable(value) {\n  return { enumerable: true, value };\n}\n\nfunction valueEnumerableWritable(value) {\n  return { enumerable: true, writable: true, value };\n}\n\nlet d = {};\nlet truthy = () => true;\nlet empty = () => ({});\nlet identity = a => a;\nlet callBoth = (par, fn, self, args) => par.apply(self, args) && fn.apply(self, args);\nlet callForward = (par, fn, self, [a, b]) => fn.call(self, par.call(self, a, b), b);\nlet create = (a, b) => Object.freeze(Object.create(a, b));\n\nfunction stack(fns, def, caller) {\n  return fns.reduce((par, fn) => {\n    return function(...args) {\n      return caller(par, fn, this, args);\n    };\n  }, def);\n}\n\nfunction fnType(fn) {\n  return create(this, { fn: valueEnumerable(fn) });\n}\n\nlet reduceType = {};\nlet reduce = fnType.bind(reduceType);\nlet action = fn => reduce((ctx, ev) => !!~fn(ctx, ev) && ctx);\n\nlet guardType = {};\nlet guard = fnType.bind(guardType);\n\nfunction filter(Type, arr) {\n  return arr.filter(value => Type.isPrototypeOf(value));\n}\n\nfunction makeTransition(from, to, ...args) {\n  let guards = stack(filter(guardType, args).map(t => t.fn), truthy, callBoth);\n  let reducers = stack(filter(reduceType, args).map(t => t.fn), identity, callForward);\n  return create(this, {\n    from: valueEnumerable(from),\n    to: valueEnumerable(to),\n    guards: valueEnumerable(guards),\n    reducers: valueEnumerable(reducers)\n  });\n}\n\nlet transitionType = {};\nlet immediateType = {};\nlet transition = makeTransition.bind(transitionType);\nlet immediate = makeTransition.bind(immediateType, null);\n\nfunction enterImmediate(machine, service, event) {\n  return transitionTo(service, machine, event, this.immediates) || machine;\n}\n\nfunction transitionsToMap(transitions) {\n  let m = new Map();\n  for(let t of transitions) {\n    if(!m.has(t.from)) m.set(t.from, []);\n    m.get(t.from).push(t);\n  }\n  return m;\n}\n\nlet stateType = { enter: identity };\nfunction state(...args) {\n  let transitions = filter(transitionType, args);\n  let immediates = filter(immediateType, args);\n  let desc = {\n    final: valueEnumerable(args.length === 0),\n    transitions: valueEnumerable(transitionsToMap(transitions))\n  };\n  if(immediates.length) {\n    desc.immediates = valueEnumerable(immediates);\n    desc.enter = valueEnumerable(enterImmediate);\n  }\n  return create(stateType, desc);\n}\n\nlet invokeFnType = {\n  enter(machine2, service, event) {\n    let rn = this.fn.call(service, service.context, event);\n    if(machine.isPrototypeOf(rn))\n      return create(invokeMachineType, {\n        machine: valueEnumerable(rn),\n        transitions: valueEnumerable(this.transitions)\n      }).enter(machine2, service, event)\n    rn.then(data => service.send({ type: 'done', data }))\n      .catch(error => service.send({ type: 'error', error }));\n    return machine2;\n  }\n};\nlet invokeMachineType = {\n  enter(machine, service, event) {\n    service.child = interpret(this.machine, s => {\n      service.onChange(s);\n      if(service.child == s && s.machine.state.value.final) {\n        delete service.child;\n        service.send({ type: 'done', data: s.context });\n      }\n    }, service.context, event);\n    if(service.child.machine.state.value.final) {\n      let data = service.child.context;\n      delete service.child;\n      return transitionTo(service, machine, { type: 'done', data }, this.transitions.get('done'));\n    }\n    return machine;\n  }\n};\nfunction invoke(fn, ...transitions) {\n  let t = valueEnumerable(transitionsToMap(transitions));\n  return machine.isPrototypeOf(fn) ?\n    create(invokeMachineType, {\n      machine: valueEnumerable(fn),\n      transitions: t\n    }) :\n    create(invokeFnType, {\n      fn: valueEnumerable(fn),\n      transitions: t\n    });\n}\n\nlet machine = {\n  get state() {\n    return {\n      name: this.current,\n      value: this.states[this.current]\n    };\n  }\n};\n\nfunction createMachine(current, states, contextFn = empty) {\n  if(typeof current !== 'string') {\n    contextFn = states || empty;\n    states = current;\n    current = Object.keys(states)[0];\n  }\n  if(d._create) d._create(current, states);\n  return create(machine, {\n    context: valueEnumerable(contextFn),\n    current: valueEnumerable(current),\n    states: valueEnumerable(states)\n  });\n}\n\nfunction transitionTo(service, machine, fromEvent, candidates) {\n  let { context } = service;\n  for(let { to, guards, reducers } of candidates) {  \n    if(guards(context, fromEvent)) {\n      service.context = reducers.call(service, context, fromEvent);\n\n      let original = machine.original || machine;\n      let newMachine = create(original, {\n        current: valueEnumerable(to),\n        original: { value: original }\n      });\n\n      if (d._onEnter) d._onEnter(machine, to, service.context, context, fromEvent);\n      let state = newMachine.state.value;\n      return state.enter(newMachine, service, fromEvent);\n    }\n  }\n}\n\nfunction send(service, event) {\n  let eventName = event.type || event;\n  let { machine } = service;\n  let { value: state, name: currentStateName } = machine.state;\n  \n  if(state.transitions.has(eventName)) {\n    return transitionTo(service, machine, event, state.transitions.get(eventName)) || machine;\n  } else {\n    if(d._send) d._send(eventName, currentStateName);\n  }\n  return machine;\n}\n\nlet service = {\n  send(event) {\n    this.machine = send(this, event);\n    \n    // TODO detect change\n    this.onChange(this);\n  }\n};\n\nfunction interpret(machine, onChange, initialContext, event) {\n  let s = Object.create(service, {\n    machine: valueEnumerableWritable(machine),\n    context: valueEnumerableWritable(machine.context(initialContext, event)),\n    onChange: valueEnumerable(onChange)\n  });\n  s.send = s.send.bind(s);\n  s.machine = s.machine.state.value.enter(s.machine, s, event);\n  return s;\n}\n\nexports.action = action;\nexports.createMachine = createMachine;\nexports.d = d;\nexports.guard = guard;\nexports.immediate = immediate;\nexports.interpret = interpret;\nexports.invoke = invoke;\nexports.reduce = reduce;\nexports.state = state;\nexports.transition = transition;\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { decode, encode } from \"@msgpack/msgpack\";\nimport {\n  ContextFunction,\n  InterpretOnChangeFunction,\n  Service,\n  createMachine,\n  guard,\n  immediate,\n  interpret,\n  reduce,\n  state,\n  transition,\n} from \"robot3\";\nimport { TOKEN_EXPIRATION_SECONDS, getTemporaryAuthToken } from \"./auth\";\nimport { ApiError } from \"./response\";\nimport { isBrowser } from \"./runtime\";\nimport { ensureAppIdFormat, isReact, throttle } from \"./utils\";\n\n// Define the context\ninterface Context {\n  token?: string;\n  enqueuedMessage?: any;\n  websocket?: WebSocket;\n  error?: Error;\n}\n\nconst initialState: ContextFunction<Context> = () => ({\n  enqueuedMessage: undefined,\n});\n\ntype SendEvent = { type: \"send\"; message: any };\ntype AuthenticatedEvent = { type: \"authenticated\"; token: string };\ntype InitiateAuthEvent = { type: \"initiateAuth\" };\ntype UnauthorizedEvent = { type: \"unauthorized\"; error: Error };\ntype ConnectedEvent = { type: \"connected\"; websocket: WebSocket };\ntype ConnectionClosedEvent = {\n  type: \"connectionClosed\";\n  code: number;\n  reason: string;\n};\n\ntype Event =\n  | SendEvent\n  | AuthenticatedEvent\n  | InitiateAuthEvent\n  | UnauthorizedEvent\n  | ConnectedEvent\n  | ConnectionClosedEvent;\n\nfunction hasToken(context: Context): boolean {\n  return context.token !== undefined;\n}\n\nfunction noToken(context: Context): boolean {\n  return !hasToken(context);\n}\n\nfunction enqueueMessage(context: Context, event: SendEvent): Context {\n  return {\n    ...context,\n    enqueuedMessage: event.message,\n  };\n}\n\nfunction closeConnection(context: Context): Context {\n  if (context.websocket && context.websocket.readyState === WebSocket.OPEN) {\n    context.websocket.close();\n  }\n  return {\n    ...context,\n    websocket: undefined,\n  };\n}\n\nfunction sendMessage(context: Context, event: SendEvent): Context {\n  if (context.websocket && context.websocket.readyState === WebSocket.OPEN) {\n    if (event.message instanceof Uint8Array) {\n      context.websocket.send(event.message);\n    } else {\n      context.websocket.send(encode(event.message));\n    }\n\n    return {\n      ...context,\n      enqueuedMessage: undefined,\n    };\n  }\n  return {\n    ...context,\n    enqueuedMessage: event.message,\n  };\n}\n\nfunction expireToken(context: Context): Context {\n  return {\n    ...context,\n    token: undefined,\n  };\n}\n\nfunction setToken(context: Context, event: AuthenticatedEvent): Context {\n  return {\n    ...context,\n    token: event.token,\n  };\n}\n\nfunction connectionEstablished(\n  context: Context,\n  event: ConnectedEvent,\n): Context {\n  return {\n    ...context,\n    websocket: event.websocket,\n  };\n}\n\n// State machine\nconst connectionStateMachine = createMachine(\n  \"idle\",\n  {\n    idle: state(\n      transition(\"send\", \"connecting\", reduce(enqueueMessage)),\n      transition(\"expireToken\", \"idle\", reduce(expireToken)),\n      transition(\"close\", \"idle\", reduce(closeConnection)),\n    ),\n    connecting: state(\n      transition(\"connecting\", \"connecting\"),\n      transition(\"connected\", \"active\", reduce(connectionEstablished)),\n      transition(\"connectionClosed\", \"idle\", reduce(closeConnection)),\n      transition(\"send\", \"connecting\", reduce(enqueueMessage)),\n      transition(\"close\", \"idle\", reduce(closeConnection)),\n      immediate(\"authRequired\", guard(noToken)),\n    ),\n    authRequired: state(\n      transition(\"initiateAuth\", \"authInProgress\"),\n      transition(\"send\", \"authRequired\", reduce(enqueueMessage)),\n      transition(\"close\", \"idle\", reduce(closeConnection)),\n    ),\n    authInProgress: state(\n      transition(\"authenticated\", \"connecting\", reduce(setToken)),\n      transition(\n        \"unauthorized\",\n        \"idle\",\n        reduce(expireToken),\n        reduce(closeConnection),\n      ),\n      transition(\"send\", \"authInProgress\", reduce(enqueueMessage)),\n      transition(\"close\", \"idle\", reduce(closeConnection)),\n    ),\n    active: state(\n      transition(\"send\", \"active\", reduce(sendMessage)),\n      transition(\"unauthorized\", \"idle\", reduce(expireToken)),\n      transition(\"connectionClosed\", \"idle\", reduce(closeConnection)),\n      transition(\"close\", \"idle\", reduce(closeConnection)),\n    ),\n    failed: state(\n      transition(\"send\", \"failed\"),\n      transition(\"close\", \"idle\", reduce(closeConnection)),\n    ),\n  },\n  initialState,\n);\n\ntype WithRequestId = {\n  request_id: string;\n};\n\n/**\n * A connection object that allows you to `send` request payloads to a\n * realtime endpoint.\n */\nexport interface RealtimeConnection<Input> {\n  send(input: Input & Partial<WithRequestId>): void;\n\n  close(): void;\n}\n\n/**\n * Options for connecting to the realtime endpoint.\n */\nexport interface RealtimeConnectionHandler<Output> {\n  /**\n   * The connection key. This is used to reuse the same connection\n   * across multiple calls to `connect`. This is particularly useful in\n   * contexts where the connection is established as part of a component\n   * lifecycle (e.g. React) and the component is re-rendered multiple times.\n   */\n  connectionKey?: string;\n\n  /**\n   * If `true`, the connection will only be established on the client side.\n   * This is useful for frameworks that reuse code for both server-side\n   * rendering and client-side rendering (e.g. Next.js).\n   *\n   * This is set to `true` by default when running on React in the server.\n   * Otherwise, it is set to `false`.\n   *\n   * Note that more SSR frameworks might be automatically detected\n   * in the future. In the meantime, you can set this to `true` when needed.\n   */\n  clientOnly?: boolean;\n\n  /**\n   * The throtle duration in milliseconds. This is used to throtle the\n   * calls to the `send` function. Realtime apps usually react to user\n   * input, which can be very frequent (e.g. fast typing or mouse/drag movements).\n   *\n   * The default value is `128` milliseconds.\n   */\n  throttleInterval?: number;\n\n  /**\n   * Configures the maximum amount of frames to store in memory before starting to drop\n   * old ones for in favor of the newer ones. It must be between `1` and `60`.\n   *\n   * The recommended is `2`. The default is `undefined` so it can be determined\n   * by the app (normally is set to the recommended setting).\n   */\n  maxBuffering?: number;\n\n  /**\n   * Callback function that is called when a result is received.\n   * @param result - The result of the request.\n   */\n  onResult(result: Output & WithRequestId): void;\n\n  /**\n   * Callback function that is called when an error occurs.\n   * @param error - The error that occurred.\n   */\n  onError?(error: ApiError<any>): void;\n}\n\nexport interface RealtimeClient {\n  /**\n   * Connect to the realtime endpoint. The default implementation uses\n   * WebSockets to connect to fal function endpoints that support WSS.\n   *\n   * @param app the app alias or identifier.\n   * @param handler the connection handler.\n   */\n  connect<Input = any, Output = any>(\n    app: string,\n    handler: RealtimeConnectionHandler<Output>,\n  ): RealtimeConnection<Input>;\n}\n\ntype RealtimeUrlParams = {\n  token: string;\n  maxBuffering?: number;\n};\n\nfunction buildRealtimeUrl(\n  app: string,\n  { token, maxBuffering }: RealtimeUrlParams,\n): string {\n  if (maxBuffering !== undefined && (maxBuffering < 1 || maxBuffering > 60)) {\n    throw new Error(\"The `maxBuffering` must be between 1 and 60 (inclusive)\");\n  }\n  const queryParams = new URLSearchParams({\n    fal_jwt_token: token,\n  });\n  if (maxBuffering !== undefined) {\n    queryParams.set(\"max_buffering\", maxBuffering.toFixed(0));\n  }\n  const appId = ensureAppIdFormat(app);\n  return `wss://fal.run/${appId}/realtime?${queryParams.toString()}`;\n}\n\nconst DEFAULT_THROTTLE_INTERVAL = 128;\n\nfunction isUnauthorizedError(message: any): boolean {\n  // TODO we need better protocol definition with error codes\n  return message[\"status\"] === \"error\" && message[\"error\"] === \"Unauthorized\";\n}\n\n/**\n * See https://www.rfc-editor.org/rfc/rfc6455.html#section-7.4.1\n */\nconst WebSocketErrorCodes = {\n  NORMAL_CLOSURE: 1000,\n  GOING_AWAY: 1001,\n};\n\ntype ConnectionStateMachine = Service<typeof connectionStateMachine> & {\n  throttledSend: (\n    event: Event,\n    payload?: any,\n  ) => void | Promise<void> | undefined;\n};\n\ntype ConnectionOnChange = InterpretOnChangeFunction<\n  typeof connectionStateMachine\n>;\n\ntype RealtimeConnectionCallback = Pick<\n  RealtimeConnectionHandler<any>,\n  \"onResult\" | \"onError\"\n>;\n\nconst connectionCache = new Map<string, ConnectionStateMachine>();\nconst connectionCallbacks = new Map<string, RealtimeConnectionCallback>();\nfunction reuseInterpreter(\n  key: string,\n  throttleInterval: number,\n  onChange: ConnectionOnChange,\n) {\n  if (!connectionCache.has(key)) {\n    const machine = interpret(connectionStateMachine, onChange);\n    connectionCache.set(key, {\n      ...machine,\n      throttledSend:\n        throttleInterval > 0\n          ? throttle(machine.send, throttleInterval, true)\n          : machine.send,\n    });\n  }\n  return connectionCache.get(key) as ConnectionStateMachine;\n}\n\nconst noop = () => {\n  /* No-op */\n};\n\n/**\n * A no-op connection that does not send any message.\n * Useful on the frameworks that reuse code for both ssr and csr (e.g. Next)\n * so the call when doing ssr has no side-effects.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst NoOpConnection: RealtimeConnection<any> = {\n  send: noop,\n  close: noop,\n};\n\nfunction isSuccessfulResult(data: any): boolean {\n  return (\n    data.status !== \"error\" &&\n    data.type !== \"x-fal-message\" &&\n    !isFalErrorResult(data)\n  );\n}\n\ntype FalErrorResult = {\n  type: \"x-fal-error\";\n  error: string;\n  reason: string;\n};\n\nfunction isFalErrorResult(data: any): data is FalErrorResult {\n  return data.type === \"x-fal-error\";\n}\n\n/**\n * The default implementation of the realtime client.\n */\nexport const realtimeImpl: RealtimeClient = {\n  connect<Input, Output>(\n    app: string,\n    handler: RealtimeConnectionHandler<Output>,\n  ): RealtimeConnection<Input> {\n    const {\n      // if running on React in the server, set clientOnly to true by default\n      clientOnly = isReact() && !isBrowser(),\n      connectionKey = crypto.randomUUID(),\n      maxBuffering,\n      throttleInterval = DEFAULT_THROTTLE_INTERVAL,\n    } = handler;\n    if (clientOnly && !isBrowser()) {\n      return NoOpConnection;\n    }\n\n    let previousState: string | undefined;\n\n    // Although the state machine is cached so we don't open multiple connections,\n    // we still need to update the callbacks so we can call the correct references\n    // when the state machine is reused. This is needed because the callbacks\n    // are passed as part of the handler object, which can be different across\n    // different calls to `connect`.\n    connectionCallbacks.set(connectionKey, {\n      onError: handler.onError,\n      onResult: handler.onResult,\n    });\n    const getCallbacks = () =>\n      connectionCallbacks.get(connectionKey) as RealtimeConnectionCallback;\n    const stateMachine = reuseInterpreter(\n      connectionKey,\n      throttleInterval,\n      ({ context, machine, send }) => {\n        const { enqueuedMessage, token } = context;\n        if (machine.current === \"active\" && enqueuedMessage) {\n          send({ type: \"send\", message: enqueuedMessage });\n        }\n        if (\n          machine.current === \"authRequired\" &&\n          token === undefined &&\n          previousState !== machine.current\n        ) {\n          send({ type: \"initiateAuth\" });\n          getTemporaryAuthToken(app)\n            .then((token) => {\n              send({ type: \"authenticated\", token });\n              const tokenExpirationTimeout = Math.round(\n                TOKEN_EXPIRATION_SECONDS * 0.9 * 1000,\n              );\n              setTimeout(() => {\n                send({ type: \"expireToken\" });\n              }, tokenExpirationTimeout);\n            })\n            .catch((error) => {\n              send({ type: \"unauthorized\", error });\n            });\n        }\n        if (\n          machine.current === \"connecting\" &&\n          previousState !== machine.current &&\n          token !== undefined\n        ) {\n          const ws = new WebSocket(\n            buildRealtimeUrl(app, { token, maxBuffering }),\n          );\n          ws.onopen = () => {\n            send({ type: \"connected\", websocket: ws });\n          };\n          ws.onclose = (event) => {\n            if (event.code !== WebSocketErrorCodes.NORMAL_CLOSURE) {\n              const { onError = noop } = getCallbacks();\n              onError(\n                new ApiError({\n                  message: `Error closing the connection: ${event.reason}`,\n                  status: event.code,\n                }),\n              );\n            }\n            send({ type: \"connectionClosed\", code: event.code });\n          };\n          ws.onerror = (event) => {\n            // TODO specify error protocol for identified errors\n            const { onError = noop } = getCallbacks();\n            onError(new ApiError({ message: \"Unknown error\", status: 500 }));\n          };\n          ws.onmessage = (event) => {\n            const { onResult } = getCallbacks();\n\n            // Handle binary messages as msgpack messages\n            if (event.data instanceof ArrayBuffer) {\n              const result = decode(new Uint8Array(event.data));\n              onResult(result);\n              return;\n            }\n            if (event.data instanceof Uint8Array) {\n              const result = decode(event.data);\n              onResult(result);\n              return;\n            }\n            if (event.data instanceof Blob) {\n              event.data.arrayBuffer().then((buffer) => {\n                const result = decode(new Uint8Array(buffer));\n                onResult(result);\n              });\n              return;\n            }\n\n            // Otherwise handle strings as plain JSON messages\n            const data = JSON.parse(event.data);\n\n            // Drop messages that are not related to the actual result.\n            // In the future, we might want to handle other types of messages.\n            // TODO: specify the fal ws protocol format\n            if (isUnauthorizedError(data)) {\n              send({ type: \"unauthorized\", error: new Error(\"Unauthorized\") });\n              return;\n            }\n            if (isSuccessfulResult(data)) {\n              onResult(data);\n              return;\n            }\n            if (isFalErrorResult(data)) {\n              if (data.error === \"TIMEOUT\") {\n                // Timeout error messages just indicate that the connection hasn't\n                // received an incoming message for a while. We don't need to\n                // handle them as errors.\n                return;\n              }\n              const { onError = noop } = getCallbacks();\n              onError(\n                new ApiError({\n                  message: `${data.error}: ${data.reason}`,\n                  // TODO better error status code\n                  status: 400,\n                  body: data,\n                }),\n              );\n              return;\n            }\n          };\n        }\n        previousState = machine.current;\n      },\n    );\n\n    const send = (input: Input & Partial<WithRequestId>) => {\n      // Use throttled send to avoid sending too many messages\n\n      const message =\n        input instanceof Uint8Array\n          ? input\n          : {\n              ...input,\n              request_id: input[\"request_id\"] ?? crypto.randomUUID(),\n            };\n\n      stateMachine.throttledSend({\n        type: \"send\",\n        message,\n      });\n    };\n\n    const close = () => {\n      stateMachine.send({ type: \"close\" });\n    };\n\n    return {\n      send,\n      close,\n    };\n  },\n};\n", "export { config, getConfig } from \"./config\";\nexport { queue, run, subscribe } from \"./function\";\nexport { withMiddleware, withProxy } from \"./middleware\";\nexport type { RequestMiddleware } from \"./middleware\";\nexport { realtimeImpl as realtime } from \"./realtime\";\nexport { ApiError, ValidationError } from \"./response\";\nexport type { ResponseHandler } from \"./response\";\nexport { storageImpl as storage } from \"./storage\";\nexport { stream } from \"./streaming\";\nexport type {\n  QueueStatus,\n  ValidationErrorInfo,\n  WebHookResponse,\n} from \"./types\";\nexport { parseAppId } from \"./utils\";\n"],
  "mappings": "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",
  "names": ["config", "fetch", "__awaiter", "fetch", "createParser", "onParse", "isFirstChunk", "buffer", "startingPosition", "startingFieldLength", "eventId", "eventName", "data", "reset", "feed", "chunk", "hasBom", "slice", "BOM", "length", "position", "discardTrailingNewline", "lineLength", "fieldLength", "character", "index", "parseEventStreamLine", "lineBuffer", "type", "id", "event", "noValue", "field", "step", "valueLength", "value", "toString", "concat", "includes", "retry", "parseInt", "Number", "isNaN", "every", "charCode", "charCodeAt", "__awaiter", "endpointId", "options", "fetch", "_a", "reader", "__await", "url", "__awaiter", "_a", "ExtData", "DecodeError", "ExtensionCodec", "encode", "decode", "Encoder", "CachedKeyDecoder", "Decoder", "__await", "machine", "service", "state", "send", "token"]
}
